[{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/notes/foundation/game101/","section":"Notes","summary":"","title":"Game101","type":"notes"},{"content":"","date":"2025-06-26","externalUrl":null,"permalink":"/zh-cn/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":" 01 一般的渲染过程 # 渲染流程 # flowchart LR 模型 --\u003e 输入结构 输入结构 --\u003e 顶点Shader 顶点Shader --\u003e 输出结构 输出结构 --\u003e 像素Shader 组件 功能 模型 包含顶点信息 (如:v 1.0 1.0 -1.0, ID 由顺序决定)、三角面信息 (如:f 5 3 1, 数字为顶点 ID), 以及 UV、法线、顶点色等 输入结构 选择需要用到的模型信息 顶点Shader 处理输入信息,将每个顶点的位置换算到屏幕空间,并计算/赋值其他逐顶点信息 (如 UV、顶点色、法线等) 输出结构 输出指定的顶点信息 像素Shader 结合环境、光照、摄像机等,输出最终渲染结果 向量 # 关于向量的说明,这一份文章讲解得比较详细\n线性代数的本质 - 01 172 字\u0026middot;1 分钟 兰伯特 # 它是主光源向量和法线向量的点乘结果, 值域在[-1,1]区间, 视觉上表现出明暗关系, max(0, nDir·lDir), 只取正值. Lambert * 0.5 + 0.5被称为半兰伯特, 暗部更柔和.\n代码 # float lambert = max(0.0, nDotl); float2 uv = float2(lambert, 0.0); float4 var_MainTex = tex2D(_MainTex, uv); return float4(var_MainTex); 02 案例讲解 # 复数高光 # 利用法线的偏移,制造出多个高光区域,丰富物体表面的高光表现.\n屏幕UV # 通过将屏幕 UV 与深度值相乘,可以让纹理依附于物体表面,并始终面向摄像机.\n算法组合 # 纹理节点 # 通过屏幕坐标系乘以 tiling 数量,取小数后限定在 [-0.5, 0.5] 区间,再接入 Length 节点.\nPower # 对值进行幂运算,调节高光或其他效果的形状.\nLength # Length = √(x^2 + y^2 + z^2),x=y 时,x=-0.5 或 0.5 时结果为 √0.5,x=0 时结果为 0,形成周期性循环.\n03 FlatCol # FlatCol 表现的是一个单色的渲染结果.之前的案例都是用 ShaderForge 节点方式制作,这里开始用代码实现材质.代码实现的材质在性能和灵活性上有优势,因为最终输出的指令更精简.\n代码示例 # Shader \u0026#34;Zhuangdong/AP1/L02/Lambert_U_01\u0026#34; { Properties{} SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } CGPROGRAM//着色器编译指令 #pragma vertex vert//声明顶点着色器 #pragma fragment frag//声明片段着色器 #include \u0026#34;UnityCG.cginc\u0026#34;//引入 Unity 内置 CG 库 #pragma multi_compile_fwdbase_fullshadows//启用阴影功能 #pragma target 3.0//指定 shader 模型版本 //上面这些类似上下文,但功能更多. //声明顶点着色器和片段着色器,下面的 vert,frag 函数才能启用. //还可以选择开启和关闭功能,比如启用阴影功能.以及指定 shader 模型版本 struct VertexInput { //导入模型顶点信息和法线信息 //POSITION NORMAL 这类词可以看 UNITY 官方 Document 查看意思 float4 vertex : POSITION; float3 normal : NORMAL; }; struct VertexOutput { //通过上面的模型顶点信息换算成顶点屏幕位置 //模型法线信息换算成世界空间法线信息 float4 pos : SV_POSITION; float3 nDirWS : TEXCOORD0; }; VertexOutput vert(VertexInput v) { //顶点着色器固定写法 v2f vert (appdata v), Output vert (input 变量名) VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex);//模型顶点位置转换成顶点屏幕位置 o.nDirWS = UnityObjectToWorldNormal(v.normal);//法线转成世界法线 return o; } float4 frag(VertexOutput i) : COLOR{ //片段着色器固定写法 float3 nDir = i.nDirWS; float3 lDir = normalize(_WorldSpaceLightPos0.xyz); //0 代表平行光,后面 xyz 代表方向,1 代表点光,xyz 代表点光坐标 //normalize 归一化保证渲染结果不出错 float nDotl = (dot(nDir, lDir)*0.5+0.5);//halflambert float lambert = max(0.0, nDotl); //有的手机机型会把 0 视为 0.1 这类小数,所以最好写 0.0,不然会出错. //使用 max 而不是 clamp,是因为 clamp 限制两头,max 限制一头,更省性能,因为点乘不会大于 1 return float4(lambert, lambert, lambert, 1.0); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 其他案例: # 用 float4 自定义光源方向,实现自定义兰伯特模型 兰伯特模型乘以 float4 可自定义光源颜色 兰伯特模型乘以 float 可自定义光强 04 案例讲解 # SSS 材质 # 这个案例的核心思路是用贴图和参数一起控制明暗交界的颜色和范围.贴图 U 轴前半段是黑色,后半段从暗到亮渐变.通过调整参数,可以让明暗交界线附近的颜色和范围随意变化.这种效果常用于模拟生物皮肤的半透明感,叫做 SSS 效果\nStep遮罩 # 该案例使用 step 函数对光照模型进行分层.step 函数可以把灰度图变成黑白分明的遮罩.使用自定义颜色,R/G/B 通道各自和 Lambert 混合,生成不同遮罩,最后混合所有遮罩输出\n特殊案例 # 该案例混合了贴图和光照模型,再通过 Round 对混合结果进行分区,从而得到自定义的结果.\n使用两组 Tiling 值不同的贴图进行混合,再调整灰度,得到最终贴图 用 Half Dir 和法线点乘,得到特殊的光照模型,能让光照随摄像机变化 灰度图和光照模型混合,结果再用 round 节点处理,得到只有黑白两色的分界 最后给黑白区域分别赋予不同颜色 LUT # LUT(Look Up Texture) 原理简述\n$$ D(\\theta) = \\frac{\\int_{-\\pi}^{\\pi} \\cos(\\theta + x) \\cdot R(2\\sin(x/2))dx}{\\int_{-\\pi}^{\\pi} R(2\\sin(x/2))dx} $$\n该公式是理论推导, 及理论生成LUT图的过程. Pre-Integrated Skin Shading 是理论生成LUT图的工具, 并且附带源码\n05 漫反射与镜面反射 # 漫反射 # Lambert,nDotl, 方向无关.现实中的案例有电影屏幕\n镜面反射 # Phong/Blinn-Phong,rDotv/nDoth, 观察方向相关.现实中的案例有车漆\n常用向量 # 向量 功能 nDir 法线方向 lDir 光源方向 vDir 视方向 rDir 光的反射方向,r = reflect(-l, n) hDir 半角方向,ldir 和 vdir 中间的向量 nDoth hDir 和 nDir 越接近,输出的值越接近 1 高光调节 # Power = Value^Exp 常用于 Phong 模型的公式,通过 Exp 控制高光的范围\n案例 # 漫反射和镜面反射结合\n// 片段着色器示例 float3 nDir = normalize(i.nDirWS); float3 lDir = _WorldSpaceLightPos0.xyz; float3 vDir = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz); float3 rDir = reflect(-lDir, nDir); float rDotv = dot(rDir, vDir); float nDotl = dot(nDir, lDir); float Lambert = nDotl * 0.5 + 0.5; float Phong = pow(max(0.0, rDotv), _SpecPow); float3 FinalColor = _BaseColor * Lambert + Phong; return float4(FinalColor, 1.0); TEXCOORD 寄存器占位符,相当于 GPU 管线中预留给开发者使用的寄存器空位,默认是 float4. 作用是标记顶点数据在着色器中的输入位置,用于传递 UV 和 自定义向量数据\n06 案例讲解 # FakeEnvReflect # 该案例把 cloud2 贴图的灰度值映射到 U 坐标,实现将随机灰度分布应用到光照效果上.\n葡萄 # 案例使用兰伯特光照模型和 LUTRampTex 作为漫反射,高光部分则使用 Phong 模型.最后通过 cloud2 贴图调整颜色和高光变化.\n漆面金属 # 该案例用 cloud2 生成遮罩,lerp 混合不同材质表现.一部分有镜面反射,一部分没有.\nBRDF # 可以理解为一个函数,输入光线、视角和表面参数,输出反射分布.Lambert 和 Phong 都是常见的 BRDF 模型.\nBRDFExplorer # 可以自定义参数,制作自己的 BRDF,并查看常见 Shader 的源码.\n07 闭塞与投影 # 三色环境光 # 该案例利用 normal 的三个通道,制作 Top/Side/Bottom 三层遮罩.用于模拟三种不同方向的环境光对光照模型的影响\nfloat3 nDir = i.nDirWS; float TopMask = max(0.0, nDir.g); float BotMask = max(0.0, -nDir.g); float MidMask = 1 - TopMask - BotMask; float3 EnvCol = _TopCol * TopMask + _MidCol * MidMask + _BotCol * BotMask; float AO = tex2D(_AoMap, i.uv); float3 EnvLighting = EnvCol * AO; return float4(EnvLighting, 1.0); Shadow # 给光照模型添加投影\n//给 Shader 增加投影 struct VertexOutput { ... LIGHTING_COORDS(3,4)};//在 VertexOutput 加入 LIGHT_COORDS VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; ... TRANSFER_VERTEX_TO_FRAGMENT(o)//顶点着色器加入 TRANSFER_VERTEX_TO_FRAGMENT ... return o;} float4 frag(VertexOutput i) : COLOR{ float shadow = LIGHT_ATTENUATION(i);//片段着色器加入 LIGHT_ATTENUATION ...} 光照构成 # flowchart LR 光照 --\u003e 光源 光照 --\u003e 环境 光源 --\u003e 漫反射Lambert 光源 --\u003e 镜面反射Phong 漫反射Lambert --\u003e 遮挡Shadow 镜面反射Phong --\u003e 遮挡Shadow 遮挡Shadow --\u003e 结果 环境 --\u003e 漫反射3Col 环境 --\u003e 镜面反射Cubemap 漫反射3Col --\u003e 遮挡AO 镜面反射Cubemap --\u003e 遮挡AO 遮挡AO --\u003e 结果 OldSchool 案例是上述光照构成的输出结果\n08 TBN矩阵 # TBN: Tangent(Red), Bitangent(Blue), Normal(Green)\n法线贴图记录的是在模型空间的法线朝向,需要转换到世界空间才能正常显示.使用 TBN 矩阵,将法线贴图转换到世界空间.转换步骤如下:\n采样法线贴图并解码 构建 TBN 矩阵 切线空间法线转世界空间 输出世界空间法线 VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; o.posWS = mul(unity_ObjectToWorld, v.vertex); o.nDirWS = UnityObjectToWorldNormal(v.normal); o.tDirWS = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz );//切线方向 OStoWS o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w);//根据 nDir tDir 求 bDir TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } float4 frag(VertexOutput i) : COLOR{ //向量 float3 nDirTS = UnpackNormal(tex2D(_NormalMap, i.uv0)).rgb; float3x3 TBN = float3x3(i.tDirWS, i.bDirWS, i.nDirWS);//TBN 矩阵 float3 nDirWS = normalize(mul(nDirTS, TBN));//转世界空间 09 环境反射 # 菲涅尔 # 边缘发光现象,公式为 nDotv, nDir 和 vDir 垂直时输出 1, 重合时输出 0, 视觉表现为模型边缘高亮\nMatcap # view 空间法线映射 BRDF 的渲染结果,只适合静态展示,Zbrush 预览界面使用的就是 Matcap.\n贴图为圆形贴图,这是因为 MatcapMap 取 nDirVS 的 RG 通道为映射值,且法线向量满足以下公式\n$$ x^2 + y^2 + z^2 = 1 $$\n而在只取 xy 的情况下,映射出来的结果会是个圆形\nCubemap # 全景图,将摄像机周边的环境映射到一个 Cube 上.Mipmap 展示不同阶级的清晰度\nfloat3 vrDirWS = reflect(-vDirWS, nDirWS); float3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS, _CubemapMip)); 10 直播答疑 # 魔改 PBR # PBR 的由来之一就是对表面参数的概括,Shader 功能加的越多,面板参数也就越多,通过寻找参数之间的物理关系来减少面板参数就是 PBR 的内容之一.以 PBR 基于物理为核修改,叫魔改 PBR. 把一些 PBR 的 BRDF 或纹理名称移植到传统模型,那还是传统模型,不叫魔改 PBR\n手游 PBS 基于物理为核的意义:\n基于物理的光能守恒 基于物理的表面属性归纳 微表面理论 改变 UV # 法线贴图记录的是在切线空间的法线信息,切线空间的主副切线方向可直观理解为,贴图在表面处的 UV 轴方向,模型不变,切线空间变了,记录的法线信息也会变\n11 常用参数 # 常用参数和作用 # 属性类型 语法格式 说明 数值,范围 _Name (\u0026quot;名称\u0026quot;, float) = defaultVal 浮点数参数 _Name (\u0026quot;名称\u0026quot;, range(min, max)) = defaultVal 范围参数 _Name (\u0026quot;名称\u0026quot;, int) = defaultVal 整数参数 位置,向量,颜色 _Name (\u0026quot;名称\u0026quot;, vector) = (xVal, yVal, zVal, wVal) 向量参数 _Name (\u0026quot;名称\u0026quot;, color) = (rVal, gVal, bVal, aVal) 颜色参数 2D, 3D 纹理,环境球 _Name (\u0026quot;名称\u0026quot;, 2d) = \u0026quot;defaultVal\u0026quot; {} 2D纹理 _Name (\u0026quot;名称\u0026quot;, 3d) = \u0026quot;defaultVal\u0026quot; {} 3D纹理 _Name (\u0026quot;名称\u0026quot;, cube) = \u0026quot;defaultVal\u0026quot; {} 立方体贴图 [HideInInspect] [HideInInspect] _FakeLightDir(\u0026quot;伪光方向\u0026quot;, vector) = (0.0, 1.0, 0.0, 1.0) 在面板上隐藏该参数 [NoScaleOffset] [NoScaleOffset] _MainTex (\u0026quot;主贴图\u0026quot;, 2d) = \u0026quot;white\u0026quot; {} 禁用纹理的 TilingOffset 面板 [Normal] [Normal] _NormTex (\u0026quot;法线贴图\u0026quot;, 2d) = \u0026quot;bump\u0026quot; {} 标示该纹理参数为法线贴图,以激活相关自检功能 [HDR] [HDR] _EmitCol (\u0026quot;自发光颜色\u0026quot;, color) = (1.0, 1.0, 1.0, 1.0) 用于设置高动态范围颜色值; 如:灯光颜色,自发光颜色等 [Gamma] [Gamma] _EmitCol (\u0026quot;自发光颜色\u0026quot;, color) = (1.0, 1.0, 1.0, 1.0) 用于颜色参数的色彩空间的转换; 一般用于颜色空间为 Linear 的项目 [PowerSlider(value)] [PowerSlider(0.5)] _SpecPow (\u0026quot;高光次幂\u0026quot;, range(1,90)) = 30 对范围参数做 Power 处理后再传入 Shader; 纠正部分参数调节手感 [Header(Label)] [Header(Texture)] 标签,用于排版 [Space(value)] [Space(50)] 空行,用于排版 常用参数类型 # 数据类型 精度和范围 说明 fixed 11位定点数, -2.0 ~ 2.0, 精度 1/256 低精度定点数 half 16位浮点数, -60000 ~ 60000, 精度约 3 位小数 中等精度浮点数 float 32位浮点数, -3.4E38 ~ 3.4E28, 精度约 6, 7 位小数 高精度浮点数 int 32位整数 整数类型,较少使用 bool 布尔型数 布尔类型,较少使用 矩阵 float2x2, float3x3, float4x4, float2x3 诸如此类格式 浮点矩阵类型 half2x2, half3x3, half4x4, half2x3 诸如此类格式 半精度矩阵类型 纹理对象 sampler2D 2D纹理采样器 sampler3D 3D纹理采样器 samplerCUBE Cube纹理采样器 参数使用方法 # 原则上优先使用精度最低的数据类型\n经验 # 世界空间位置和 UV 坐标,使用 float 向量,HDR 颜色,使用 half; 视情况升到 float LDR 颜色,简单乘子,可使用 fixed 要点 # 不同平台对数据类型的支持情况不同; 一般会自动转换,极少数情况自动转换会带来问题 部分平台上,数据类型精度转换消耗也不小; 所以 fixed 也是慎用 多和图形开发商量 顶点 Input 数据 # 顶点Input数据 数据类型 说明 POSITION float3, float4 顶点位置 TEXCOORD0 float2, float3, float4 UV通道1 TEXCOORD1 float2, float3, float4 UV通道2 TEXCOORD2 float2, float3, float4 UV通道3 TEXCOORD3 float2, float3, float4 UV通道4 NORMAL float3 法线方向 TANGENT float4 切线方向 COLOR float4 顶点色 顶点 Output 数据 # 顶点Output数据 数据类型 说明 pos float4 顶点位置(裁剪空间) uv0 float2 一般纹理UV uv1 float2 LightmapUV posWS float3 顶点位置(世界空间) nDirWS half3 法线方向(世界空间) tDirWS half3 切线方向(世界空间) bDirWS half3 副切线方向(世界空间) color fixed4 顶点色 常用顶点Shader操作 # 注: Unity2019.3.2f1 版本\n顶点操作 代码示例 说明 pos UnityObjectToClipPos(v.vertex); 将顶点从对象空间转换到裁剪空间 uv0 o.uv0 = v.uv1; o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex_ST); 设置一般纹理UV坐标 uv1 o.uv1 = v.uv1; o.uv1 = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw; 设置LightmapUV坐标 posWS mul(unity_ObjectToWorld, v.vertex); 将顶点从对象空间转换到世界空间 nDirWS UnityObjectToWorldNormal(v.normal); 将法线从对象空间转换到世界空间 tDirWS normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0.0)).xyz); 将切线从对象空间转换到世界空间并归一化 bDirWS normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w); 计算副切线方向(法线和切线的叉积) color o.color = v.color; 传递顶点色 贴图tiling # uniform sampler2D _MainTex; uniform float4 _MainTex_ST VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; // 使用TRANSFORM_TEX宏或手动计算 o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); // 等价于: o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw; return o; } 功能模块化 # 原写法:\nfloat TopMask = max(0.0, nDirWS.g); float BotMask = max(0.0, -nDirWS.g); float MidMask = 1 - TopMask - BotMask; float3 EnvCol = _TopCol * TopMask + _MidCol * MidMask + _BotCol * BotMask; 修改后:\nfloat3 TriColAmbient (float3 n, float3 uCol, float3 sCol, float3 dCol){ float uMask = max(0.0, n.g); float dMask = max(0.0, -n.g); float sMask = 1.0 - uMask - dMask; float3 envCol = uCol * uMask + sCol * sMask + dCol * dMask; return envCol; } // 使用函数 float3 envCol = TriColAmbient(nDirWS, _EnvUpCol, _EnvSideCol, _EnvDownCol); 模块化 - 创建独立文件:\n创建 Assets\\Cgnic\\MyCgnic.cgnic:\n#ifndef MY_CGINC #define MY_CGINC float3 TriColAmbient (float3 n, float3 uCol, float3 sCol, float3 dCol){ float uMask = max(0.0, n.g); float dMask = max(0.0, -n.g); float sMask = 1.0 - uMask - dMask; float3 envCol = uCol * uMask + sCol * sMask + dCol * dMask; return envCol; } #endif 在 Shader CGPROGRAM 下新增路径来引用:\nCGPROGRAM // ... 其他代码 ... #include \u0026#34;../cginc/MyCginc.cginc\u0026#34; // ... 其他代码 ... float3 envCol = TriColAmbient(nDirWS, _EnvUpCol, _EnvSideCol, _EnvDownCol); 12 Ogre 案例 # 本案例参考了 https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish , 结合实际资源,制作了一个典型的角色 Shader.\n代码示例 # Shader \u0026#34;Zhuangdong/AP1/L06/L06_ogre_Feedback\u0026#34; { Properties{ [Header(Texture)] _MainTex (\u0026#34;RGB:基础颜色 A:透明贴图\u0026#34;, 2D) = \u0026#34;White\u0026#34; {} [Normal] _NormalMap (\u0026#34;RGB:法线贴图\u0026#34;, 2D) = \u0026#34;bump\u0026#34; {} _DetailMap (\u0026#34;RGB: Detail 细节贴图 A: 细节遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _MetalnessMask (\u0026#34;金属遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _SelfIllMask (\u0026#34;SelfIll 自发光遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _SpecTex (\u0026#34;RGB:Spec 高光贴图\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _RimLight (\u0026#34;Rim 边缘光遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _BaseTintMask (\u0026#34;Tint 底色遮罩\u0026#34;, 2D) = \u0026#34;White\u0026#34; {} _SpecularExponent (\u0026#34;SpecExpo 镜面反射指数\u0026#34;, 2D) = \u0026#34;White\u0026#34; {} _DiffuseWarp (\u0026#34;Diffuse 扩散遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _CubeMap (\u0026#34;RGB:Cube 环境贴图\u0026#34;, Cube) = \u0026#34;_Skybox\u0026#34; {} _FresnelWarp(\u0026#34;菲涅尔贴图 R:FCol G:FRim B:FSpec\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} [Header(Diffuse)] _LightCol (\u0026#34;主光颜色\u0026#34;, Color) = (1.0,1.0,1.0,1.0) [Space(10)] _TopCol (\u0026#34;顶部颜色\u0026#34;, Color) = (0.47,0.96,1,1) _MidCol (\u0026#34;中部颜色\u0026#34;, Color) = (0.46,0.7,0.45,1) _BotCol (\u0026#34;底部颜色\u0026#34;, Color) = (0.75,0.39,0.39,1) _EnvDiffInt (\u0026#34;EnvDiff 环境漫反射强度\u0026#34;, Range(0.0, 5.0)) = 0.2 [Header(Specular)] _SpecPow(\u0026#34;高光次幂\u0026#34;, Range(0.0, 90.0)) = 5 _SpecInt(\u0026#34;高光强度\u0026#34;, Range(0.0, 10.0)) = 5 [Space(10)] _EnvSpecint (\u0026#34;Envspec 环境镜反强度\u0026#34;, Range(0.0, 10.0)) = 0.2 [Header(SelfIll)] _SelfIllInt (\u0026#34;SelfIll 自发光强度\u0026#34;, Range(0, 10)) = 1 [HDR]_RimCol (\u0026#34;轮廓光颜色\u0026#34;, Color) = (1.0,1.0,1.0,1.0) _RimInt (\u0026#34;轮廓光强度\u0026#34;, Range(0.0, 3.0)) = 1.0 [HideInInspector] _Cutoff (\u0026#34;Alpha cutoff\u0026#34;, Range(0,1)) = 0.5 [HideInInspector] _Color (\u0026#34;Main Color\u0026#34;, Color) = (1,1,1,1)//Fallback Require } SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;AutoLight.cginc\u0026#34;//自动处理光照衰减来进行阴影处理 #include \u0026#34;Lighting.cginc\u0026#34;//主要用于访问环境主平行光相关数据 #pragma multi_compile_fwdbase_fullshadows //启用阴影功能 #pragma target 3.0 //Texture uniform sampler2D _MainTex; uniform sampler2D _NormalMap; uniform sampler2D _DetailMap; uniform sampler2D _MetalnessMask; uniform sampler2D _SelfIllMask; uniform sampler2D _SpecTex; uniform sampler2D _RimLight; uniform sampler2D _BaseTintMask; uniform sampler2D _SpecularExponent; uniform sampler2D _DiffuseWarp; uniform samplerCUBE _CubeMap; uniform sampler2D _FresnelWarp; //Diffuse uniform half3 _LightCol; uniform fixed3 _TopCol; uniform fixed3 _MidCol; uniform fixed3 _BotCol; uniform fixed _EnvDiffInt; //Specular uniform half _SpecPow; uniform half _SpecInt; uniform half _EnvSpecint; //SelfIll uniform fixed _SelfIllInt; uniform half3 _RimCol; uniform half _RimInt; uniform half _Cutoff; struct VertexInput { Document查看意思 float4 vertex : POSITION; float2 uv0 : TEXCOORD0; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct VertexOutput { 法线信息 float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float3 posWS : TEXCOORD1; float3 nDirWS : TEXCOORD2; float3 tDirWS : TEXCOORD3; float3 bDirWS : TEXCOORD4; LIGHTING_COORDS(5,6) }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; o.posWS = mul(unity_ObjectToWorld, v.vertex); o.nDirWS = UnityObjectToWorldNormal(v.normal); o.tDirWS = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz ); o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w); TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } float4 frag(VertexOutput i) : COLOR{ //向量 half3 nDirTS = UnpackNormal(tex2D(_NormalMap, i.uv0)).rgb; half3x3 TBN = float3x3(i.tDirWS, i.bDirWS, i.nDirWS); half3 nDirWS = normalize(mul(nDirTS, TBN)); half3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz); half3 vrDirWS = reflect(-vDirWS, nDirWS); half3 lDirWS = _WorldSpaceLightPos0.xyz; 表点光坐标,归一化比较安全,点乘结果会比较正确点 half3 lrDirWS = reflect(-lDirWS, nDirWS); float shadow = LIGHT_ATTENUATION(i); //点乘 half rDotv = dot(vDirWS, lrDirWS);//Phong half nDotl = dot(nDirWS, lDirWS);//Lambert half ndotv = dot(nDirWS, vDirWS); //采样纹理 half4 var_MainTex = tex2D(_MainTex, i.uv0); half4 var_DetailMap = tex2D(_DetailMap, i.uv0); half var_MetalnessMask = tex2D(_MetalnessMask, i.uv0); half var_SelfIllMask = tex2D(_SelfIllMask, i.uv0); half var_SpecTex = tex2D(_SpecTex, i.uv0);//specInt half var_RimLight = tex2D(_RimLight, i.uv0); half var_BaseTintMask = tex2D(_BaseTintMask, i.uv0); half var_SpecularExponent = tex2D(_SpecularExponent, i.uv0);//specSize half3 var_Cubemap = texCUBElod(_CubeMap, float4(vrDirWS, lerp(8.0, 0.0, var_MetalnessMask))).rgb; half3 var_FresnelWarp = tex2D(_FresnelWarp, ndotv); //提取信息 half3 BaseCol = var_MainTex.rgb; half Opacity = var_MainTex.a; half MetalMask = var_MetalnessMask; half RimLightInt = var_RimLight; half TintMask = var_BaseTintMask; half SpecExp = var_SpecularExponent; half3 EnvCube = var_Cubemap; half SpecInt = var_SpecTex; half EmitInt = var_SelfIllMask; //光照模型 half3 DiffCol = lerp(BaseCol, half3(0.0,0.0,0.0), MetalMask); //越接近金属,漫反射越弱 half3 SpecCol = lerp(BaseCol, half3(0.3,0.3,0.3), TintMask) * SpecInt; //根据 TintMask 决定高光颜色 //0.3 是经验值,这个值乘以高光强度 specInt 得到的高光颜色贴图比较舒服 //菲涅尔 half3 Fresnel = lerp(var_FresnelWarp, 0.0, MetalMask); //金属度越高,菲涅尔现象越不明显; half FreCol = Fresnel.r; //无实际用途 half FreRim = Fresnel.g; //轮廓光用 Fresnel half FreSpec = Fresnel.b; //镜面反射用 Fresnel //主光漫反射 half HalfLambert = nDotl * 0.5 + 0.5;//Halflambert half3 var_DiffuseWarp = tex2D(_DiffuseWarp, half2(HalfLambert, 0.2)); //对 Ramptexture 进行采样 half3 DirDiff = DiffCol * var_DiffuseWarp * _LightCol; //主光镜面反射 half Phong = pow(max(0.0, rDotv), SpecExp * _SpecPow); half Spec = Phong * max(0.0,nDotl); Spec = max(Spec, FreSpec); //会有个油亮的视觉效果,强烈的菲涅尔现象和 Phong 混合在一起 Spec = Spec * _SpecInt; //乘以 SpecInt 后,大部分之前 Spec 的效果会消失,只有 SpecInt 指定的范围才有亮点 //原 Shader 是将所有镜面反射整合在一起最后再 max(flMetalnessMask, flSpecWarp) //这里作者对镜面反射进行拆分,所以两边最后结算都需要进行一次 max half3 DirSpec = SpecCol * Spec * _LightCol; //环境漫反射 float TopMask = max(0.0, nDirWS.g); float BotMask = max(0.0, -nDirWS.g); float MidMask = 1 - TopMask - BotMask; float3 EnvCol = _TopCol * TopMask + _MidCol * MidMask + _BotCol * BotMask; float3 EnvDiff = DiffCol * EnvCol * _EnvDiffInt; //视频作者只用了单色,这里我是直接复制之前的案例代码没有改 //环境镜面反射 half ReflectInt = max(FreSpec, MetalMask) * SpecInt; //金属部分 MetalMask 最大,非金属 FreSpec 最大 //这样非金属有很强的菲涅尔现象,金属部分则很少,取而代之的有很强的反射现象 half3 EnvSpec = SpecCol * ReflectInt * EnvCube * _EnvSpecint; //轮廓光 half3 RimLight = _RimCol * FreRim * RimLightInt * max(0.0, nDirWS.g) * _RimInt; //轮廓光只出现在顶部,所以需要用 normal.g //FreRim 定义菲涅尔现象,RimLightInt 定义强度范围,RimInt 定义强度 //自发光 float3 emission = EmitInt * DiffCol * _SelfIllInt; //Final half3 FinalRGB = (DirDiff + DirSpec) * shadow + EnvDiff + EnvSpec + RimLight + emission; clip(Opacity - _Cutoff);//小于_Cutoff 全部删去,大于的保留 return float4(FinalRGB, 1.0); } ENDCG } } Fallback \u0026#34;Legacy Shaders/Transparent/Cutout/VertexLit\u0026#34; //注:使用 FallBack 必须声明一个_Color: 颜色,即使你用不到 } 主要问题 # Fallback 设置:指定到支持透明贴图的 Shader(如 Legacy Shaders/Transparent/Cutout/VertexLit). Cull Off:关闭背面剔除,防止模型背面被裁剪. 贴图讲解 # 贴图类型 贴图名称 说明 非共用贴图 Color 基础颜色贴图 MatelnessMask 金属遮罩,控制金属区域 Normal 法线贴图 RimMask 边缘光遮罩 SelfIllumMask 自发光遮罩 SpecularExponent 高光指数贴图 SpecularMask 高光强度遮罩 TintByBaseMask 高光染色遮罩,金属高光颜色由ColorMap决定 Translucency 半透明贴图 共用贴图 Cubemap 立方体贴图 DiffuseWarp RampTex 漫反射扭曲渐变贴图 FresnelWarpColor 菲涅尔颜色扭曲贴图 FresnelWarpRim 菲涅尔边缘光扭曲贴图 FresnelWarpSpec 菲涅尔高光扭曲贴图 贴图合并 Color: RGB: Color A: Opacity RGB通道存储颜色,A通道存储透明度 Mask1: R: SpecInt G: RimInt B: TintMask A: SpecPow R通道高光强度,G通道边缘光强度,B通道染色遮罩,A通道高光指数 Mask2: R:FresnelCol G: FresnelRim B: FresnelSpec R通道菲涅尔颜色,G通道菲涅尔边缘光,B通道菲涅尔高光 其他贴图如 ColorMap, Tramsparency, NormalMap, SelfIlluminationMask, SpecularExponent, DiffuseMask, DetailMask 之前案例接触过,或该案例不使用,故不说明\n源代码说明 # RimLightScale、SpecScale:为固定值,不同角色设定不同,主要用于边缘光和高光计算.\nSpecularScale, RimLightScale 和其他源代码有的参数,作者在不影响最终效果的情况下移除了,并对代码进行了简化\n菲涅尔与边缘光:不同角色 RimLightScale 设定不同,大部分是大于 1 的数字,在这基础下,通过 FresnelWarp 贴图和 RimMask 控制边缘高光的强度和范围,能实现夸张的卡通边缘效果.\nFresnelWarpSpec 在原 Shader 被称为 flSpecWarp, 用于定义角色的环境镜面反射\n高光与金属控制:金属部分用 cubemap 反射,非金属部分用高光贴图控制.通过 cSpecular *= max(flMetalnessMask, flSpecWarp); 实现金属和非金属的高光切换.\n主光镜面反射:Dota2 采用了更适合俯视视角的算法,核心代码如下:\n```c vec3 R = reflect (V, N); float RdotL = clamp(dot(L, -R), 0, 1); ``` 由此我们可能知道,R 和 L 越接近,光越亮.相比传统 Phong,更适合 Dota2 这种上帝视角.\n光照构成 # flowchart LR 光照 --\u003e 光源 光源 --\u003e 漫反射HalfLambert+WarpTex/Lambert 光源 --\u003e 镜面反射Phong+FresnelSpecWarp 漫反射HalfLambert+WarpTex/Lambert --\u003e 遮挡Shadow 镜面反射Phong+FresnelSpecWarp --\u003e 遮挡Shadow 遮挡Shadow --\u003e 结果 光照 --\u003e 环境 环境 --\u003e 漫反射1Col 环境 --\u003e 镜面反射Cubemap 漫反射1Col --\u003e 无AO,部分成分用RimMask代替 镜面反射Cubemap --\u003e 无AO,部分成分用RimMask代替 无AO,部分成分用RimMask代替 --\u003e 结果 轮廓光FresnelRimWarp --\u003e 结果 自发光 --\u003e 结果 经验总结 # 视频案例将原代码拆分并融入自己的体系,便于理解和扩展.初学时容易忽略 Fresnel 贴图的作用,建议多参考 Dota2 原始 Shader 和社区资源,理解每张贴图的实际用途.\n","date":"2025-06-26","externalUrl":null,"permalink":"/zh-cn/notes/courses/zhuangdongcourse/forwardrendering/","section":"笔记","summary":"","title":"庄懂的技术美术入门课 - 前向渲染","type":"notes"},{"content":"","date":"2025-06-10","externalUrl":null,"permalink":"/zh-cn/tags/space/","section":"Tags","summary":"","title":"Space","type":"tags"},{"content":"","date":"2025-06-10","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 01-向量究竟是什么? # 定义 # 向量是具有大小和方向的量\n表示方式 # 通常用箭头或带方向的线段表示 关键属性是长度 (模长) 和方向 示例:向量 (-2, 3) 表示从原点 (0,0) 指向点 (-2,3) 的箭头 向量模长计算公式 # $$ |\\vec{v}| = \\sqrt{x^2 + y^2} $$\n特征 # 存在多维向量 (二维/三维在游戏领域最常用) 本质是有序数字列表,可代表多种事物 向量相加 # 可以视作从原点沿两个向量方向移动,比如向量 V+ 向量 W,意味着我们先往向量 V 方向移动,再往向量 W 方向移动,移动距离为它们的模长\n向量相加公式 # $$ \\vec{a} + \\vec{b} = \\begin{bmatrix} x_1 \\ y_1 \\end{bmatrix} + \\begin{bmatrix} x_2 \\ y_2 \\end{bmatrix} = \\begin{bmatrix} x_1 + x_2 \\ y_1 + y_2 \\end{bmatrix} $$\n向量和标量相乘 # 也可以称作向量的缩放\n数乘公式 # $$ \\vec{v} = k \\cdot \\vec{v} = (k v_x, k v_y, k v_z) $$\n02-线性组合,张成的空间与基 # 基向量 # 在二维坐标系 (xy 平面) 中,有两个特殊的向量,一个指向正右方,长度为 1, 称为 \u0026ldquo;i 帽\u0026rdquo;, 另一个指向正上方,长度为 1, 称为 \u0026ldquo;j 帽\u0026rdquo;, 这两个向量共同构成该坐标系的 \u0026ldquo;基向量\u0026rdquo;, 它们是坐标系的基础框架.\n例如,向量 (3, -2) 可以理解为\n将基向量 i 帽拉伸 3 倍 将基向量 j 帽拉伸 2 倍 最终向量 (3, -2) 就是这两个缩放后的向量的和 (3i + (-2j)) 这里,坐标值 3 和 -2 被视为标量,而基向量则是被这些标量缩放的对象\n线性组合 # 两个向量标量乘法之和被称为线性组合\n$$ \\vec{U} = a\\vec{V} + b\\vec{W} $$\na,b 为标量\n张成空间 # 想象你有几个箭头,张成空间就是只用这些箭头,通过两种最基础的操作,向量加法和数乘,你能到达的所有可能位置构成的集合\n一维 # 共线 即构成空间的向量在同一条线上\n二维 # 三维 # 存在一个向量,和其他向量不在同一个平面上,当你伸缩这个向量时,它会把平面沿它的方向移动,从而达到三维空间的任何一点\n线性相关 # 如果移除一个向量,发现张成空间没有变小,那么说明这个向量是多余的.它本身是由其他向量通过数乘和相加得到的,这类向量被称为线性相关\n线性无关 # 如果移除一个向量,发现张成空间变小,说明这个箭头不是多余的,这样的向量被称为线性无关\n基 # 向量空间的一个基,就是一组数量最少的,线性无关的向量\n能张成整个空间 都是线性无关的 ","date":"2025-06-10","externalUrl":null,"permalink":"/zh-cn/notes/foundation/linearalgebra/essenceoflinearalgebra_part1/","section":"笔记","summary":"","title":"线性代数的本质 - 01","type":"notes"},{"content":" 了解如何使用简单而强大的 Blowfish。 ","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/notes/foundation/","section":"笔记","summary":"","title":"线性代数的本质","type":"notes"},{"content":" 了解如何使用简单而强大的 Blowfish。 ","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/notes/courses/","section":"笔记","summary":"","title":"庄懂的技术美术入门课","type":"notes"},{"content":" 了解如何使用简单而强大的 Blowfish。 ","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/portfolio/","section":"作品集","summary":"","title":"作品集","type":"portfolio"},{"content":" 了解如何使用简单而强大的 Blowfish。 ","date":"2025-06-07","externalUrl":null,"permalink":"/zh-cn/notes/","section":"笔记","summary":"","title":"笔记","type":"notes"},{"content":" 了解如何使用简单而强大的 Blowfish。 ","date":"2025-06-07","externalUrl":null,"permalink":"/zh-cn/notes/courses/zhuangdongcourse/","section":"笔记","summary":"","title":"文章","type":"notes"},{"content":" 了解如何使用简单而强大的 Blowfish。 ","date":"2025-06-07","externalUrl":null,"permalink":"/zh-cn/notes/foundation/linearalgebra/","section":"笔记","summary":"","title":"文章","type":"notes"},{"content":" 22. Unity 光照烘焙系统 # 烘焙前设置 # 天空盒 # 设置天空球材质\n路径: Windows → Rendering → Lighting Settings → Skybox Material\n静态 # 为了让场景响应烘焙, 我们需要将场景物体设置成静态, 并启用 Contribute GI 和 Reflection Probe Static 这两个Flags\n各静态选项说明:\n组件 功能 Contribute GI 响应全局光照 Occluder/Occludee Static 响应遮挡剔除 (OccCulling) Batching Static 合批优化 Navigation Static/Off Mesh Link Generation 导航相关 Reflection Probe Static 决定物体是否出现在反射探头记录中 LightingMode # 路径: Windows → Rendering → Lighting Settings → MixedLighting → LightingMode\nLightingMode 选项 Directional Light Mode 选项 Baked Indirect RealTime Subtractive Mixed ShadowMask Baked 注:ShadowMask Mode 需在 ProjectSetting → Quality → Shadow → Shadowmask Mode 开启.ShadoeMask Mode 额外生成一张 Shadowmask 贴图\n组合列表 # LightingMode 选项 Directional Light Mode 选项 光照公式 投影处理 Baked Indirect RealTime LM = GI = EmitLighting + SkyLighting 实时投影 Mixed LM = GI = EmitLighting + SkyLighting + LightsGI 实时投影 Baked LM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting 静态物:投影写入LM 动态物:无 Subtractive RealTime LM = GI = EmitLighting + SkyLighting 实时投影; RealTime Shadow Color设置失效 Mixed LM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting 静态物:投影写入LM 动态物:实时; RealTime Shadow Color设置有效 Baked LM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting 静态物:投影写入LM 动态物:无; RealTime Shadow Color设置失效 ShadowMask RealTime LM-light = GI = EmitLighting + SkyLighting\nLM-shadowmask = null 实时投影 Mixed LM-light = GI = EmitLighting + SkyLighting + LightsGI\nLM-shadowmask = LightsShadow 静态物:投影写入LM 动态物:实时投影 Baked LM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting\nLM-shadowmask = null 静态物:投影写入LM 动态物:无 Lighting 说明 EmitLighting 发光材质造成的光照 SkyLighting 天空球造成的光照 LightsGI 主光造成的反弹光 LightsLighting 主光造成的光照 LM Lightmap DL DirectLighting 注:Subtractive 和 ShadowMask 对动态物体的实时投影的处理不同,ShadowMask 对动静态物的投影混合更自然\n其他设置 # 自发光材质 Global Illumination 设为 Baked,Color 设为 HDR\nLightmapper: Progressive CPU Lightmap Resolution: 40 Directional Mode: Non-Directional(一般不推荐,效果不明显,能耗翻倍) 常见方案 # 全实时光照:不需要 Lightmap 全实时直接光照 + Baked Indirect 静态物体烘焙,动态物体实时 (Subtractive/ShadowMask) 辅助光只用于烘焙 (Baked/Mixed)Mixed 决定是否影响动态物体 特效 RealTime 合批策略 # 定义 # 把渲染过程相同的几个批次的渲染合并起来,节省资源,增加速度.一般情况下,共用 Material, 参数相同才能合批\n常见策略 # Unity static 设置 Unity SRPBatching (同 Shader 即可合批) GPU Instancing 手动合批 (DDC 软件内合并模型) FrameDebugger # Windows → Analisis → FrameDebugger\nFrameDebugger 可查看合批与渲染过程\n23. 外部烘焙光照贴图 # 外部烘焙流程 # 使用 3dsMax/MAYA 烘焙 LightingMap,需为模型创建 UV2\n贴图:\nAO Map 代替 SkyLighting EmitLighting LightsShadow LightGI + LightsLighting Alpha 用 SD 的 Blur HQ 节点消除噪点,合并贴图节省资源\n光照构成 # graph LR subgraph identifier1[\" \"] direction LR 光照 结果 subgraph identifier2[\" \"] direction LR 简单光源 主平行光 漫反射Lambert 镜面反射Phong top1[遮挡LM] end subgraph identifier3[\" \"] direction LR 复杂光源 subgraph identifier4[\" \"] direction LR 漫反射Cubemap 漫反射1Col 漫反射 top2[遮挡LM] top3[遮挡LM] 忽略 subgraph identifier5[\" \"] direction LR 自发光 其他环境光 天光 end subgraph identifier6[\" \"] direction LR 遮挡SurfaceOcc 镜面反射Cubemap 衰减Fresnel end end end end 光照 ==\u003e 简单光源 简单光源 ==\u003e 主平行光 主平行光 ==\u003e 漫反射Lambert 主平行光 ==\u003e 镜面反射Phong 漫反射Lambert ==\u003e top1[遮挡LM] 镜面反射Phong ==\u003e top1[遮挡LM] top1[遮挡LM] ==\u003e 结果 光照 ==\u003e 复杂光源 复杂光源 ==\u003e 天光 复杂光源 ==\u003e 自发光 复杂光源 ==\u003e 其他环境光 天光 ==\u003e 漫反射Cubemap 漫反射Cubemap ==\u003e top2[遮挡LM] 自发光 ==\u003e 漫反射1Col 漫反射1Col ==\u003e top3[遮挡LM] 其他环境光 ==\u003e 漫反射 top2[遮挡LM] ==\u003e 结果 top3[遮挡LM] ==\u003e 结果 漫反射 ==\u003e 忽略 identifier5[\" \"] ==\u003e 镜面反射Cubemap 镜面反射Cubemap ==\u003e 遮挡SurfaceOcc 镜面反射Cubemap ==\u003e 衰减Fresnel 遮挡SurfaceOcc ==\u003e 结果 衰减Fresnel ==\u003e 结果 style identifier1 stroke:none style identifier1 fill:transparent style identifier2 stroke:none style identifier2 fill:transparent style identifier3 stroke:none style identifier3 fill:transparent style identifier4 stroke:none style identifier4 fill:transparent style identifier5 fill:transparent style identifier6 stroke:none style identifier6 fill:transparent Shader 核心结构 # Shader \u0026#34;Zhuangdong/AP1/L15/L15_LightingMap\u0026#34; { Properties{ // ... 贴图与参数声明 ... } SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; // ... 以 orge 案例为模板,顶点着色器移除 TRANSFER_VERTEX_TO_FRAGMENT(o) ... VertexOutput vert(VertexInput v) { ... //案例需要 2 个 uv, 这里将 2 个 uv 合并到一个 float4, 节省 TEXCOORD o.uvs = float4(v.uv0, v.uv1); ... } float3 DecodeNormal (float2 maskXY) { //贴图只有 RG 两个通道,我们要补上 B 通道 float2 nDirTSxy = maskXY * 2.0 - 1.0; //贴图值域在 (0,1),法线是向量,向量值域在 (-1,1) float nDirTSz = sqrt(1.0 - (nDirTSxy.x * nDirTSxy.x + nDirTSxy.y * nDirTSxy.y)); //sqrt 取平方根,x 平方+y 平方+z 平方=1 return float3(nDirTSxy, nDirTSz); } float4 frag(VertexOutput i) : COLOR { // ... 采样、向量、点乘 ... //提取表面信息 float occlusion = var_MaskTex.r; float matMask = var_MaskTex.g;//金属贴图 float3 diffCol = var_MainTex.rgb * lerp(1.0, _MetalDarken, pow(matMask, 5.0)); //这里给金属叠加_MetalDarken,降低金属部分的 diff float specPow = max(1.0, lerp(_SpecParams.x, _SpecParams.z, matMask)); float specInt = max(0.0, lerp(_SpecParams.y, _SpecParams.w, matMask)); float reflectMip = clamp(lerp(_EnvReflectParams.x, _EnvReflectParams.z, matMask), 0.0, 7.0); //clamp 即 clamp(value,min,max) 会将 value 限制在 (min,max) 中 float reflectInt = max(0.0, lerp(_EnvReflectParams.y, _EnvReflectParams.w, matMask)); float fresnel = lerp(pow(1.0 - max(0.0, ndotv), _FresnelPow), 1.0, matMask); //区分金属和非金属的 Fresnel 强度 //提取光照信息 float skyLightOcc = var_LightMap.r; float emitLightingInt = var_LightMap.g; float mainLightGIInt = pow(var_LightMap.b, _GIpow); float mainLightShadow = var_LightMap.a; //采样纹理 Cube float3 var_SkyCube = texCUBElod(_SkyCube, float4(vrDirWS, 7.0)).rgb; float3 var_EnvCube = texCUBElod(_EnvCube, float4(vrDirWS, reflectMip)).rgb; //MainLight //Diff float3 halfShadowCol = lerp(_HalfShadowCol.rgb, _MainLightCol, mainLightShadow); //获取半影颜色, 先给阴影和主光赋予颜色 float3 mainLightCol = lerp(_MainLightCol, halfShadowCol, _HalfShadowCol.a) * mainLightShadow; //再用投影 mask 去掉阴影颜色,留下的就是主光颜色和半影颜色,这里_HalfShadowCol.a 控制半影强度 float3 mainLightDiff = diffCol * mainLightCol * max(0.0, nDotl); //DiffCol*Lambert*MainLight //Spec float3 mainLightSpec = mainLightCol * pow(max(0.0, vDotr), specPow) * specInt;//Phong //GI float3 mainLightGI = _GICol * occlusion * mainLightGIInt * _GIInt; //GI 也就是主光的反弹光,这里叠加 AO 增加变化 //Mixed float3 mainLight = (mainLightDiff + mainLightSpec + mainLightGI * _MainLightGIOn) * _MainLightOn; //这里 GI 已经有环境 AO 的信息了,所以不用*LM //OtherLight float3 skyLightDiff = diffCol * var_SkyCube * _SkyCol * _SkyLightInt * skyLightOcc * occlusion; //这里是物体漫反射*天光漫反射*LM(LightingMap) float3 emitLightDiff = diffCol * _EmissionCol * emitLightingInt * occlusion; //同上,这部分不受环境 AO 影响,所以不用*_SkyLightOcc //OtherEnvSpec float3 envLightSpec = var_EnvCube * reflectInt * fresnel * occlusion; float3 OtherLight = skyLightDiff * _SkyLightOn + emitLightDiff * _EmitLightOn + envLightSpec * _EnvReflectOn; float3 finalRGB = mainLight + OtherLight; return float4(finalRGB, 1.0); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 关键参数 # 参数 说明 参数 说明 _SpecParams 高光参数 _EnvReflectParams 反射参数 x 非金属高光次幂 x 非金属 Cube 采样 Mip 值 y 非金属高光强度 y 非金属反射强度 z 金属高光次幂 z 金属 Cube 采样 Mip 值 w 金属高光强度 w 金属反射强度 要点总结 # 法线贴图只有 RG,需手动补 B 通道 半影染色 金属/非金属参数分开控制高光、反射 根据光照构成合成光照 24-26. 自定义烘焙器 # 简介 # 由于此案例代码内容过多,讲解以摘要为主,如需源代码请自行到教程处下载\n本案例实现了一个自定义烘焙器,用于完成自定义烘焙、结果预览以及材质编辑等功能.烘焙过程中会生成三张贴图,分别对应主光、天光和自发光三种光源,并最终将这三张贴图合并,输出为最终的 LightingMap.烘焙完成后,可以分别预览每一张贴图的独立效果,并可通过全局参数灵活调节最终画面表现.\n主光\n天光\n自发光\n文件结构 # 文件 说明 LightingController 负责整个烘焙流程的主脚本. LightingControllerGUI 自定义烘焙面板 (UI),让操作更直观. EmissionShaderGUI 让材质球在 Inspector 界面可以设置自发光参与 GI. Building/EmitLight/Sky 分别对应建筑、发光、天空球的 Shader. 全局参数 # 参数 说明 MetalDarken 金属部分的暗度 (影响金属表面反光强度) MainLightCol 主光颜色 SpecParams 高光参数 (x/z 为高光次幂,y/w 为高光强度,分别对应金属/非金属) SkyLightInt 天光强度 ReflectParams 反射参数 (x/z 为 CubeMap Mip,y/w 为反射强度) FresnelPow 菲涅尔现象的强度 EmissionCol 自发光颜色 烘焙流程 # 收集场景烘焙信息:包括贴图数量、路径、纹理对象 创建缓存:为主光、天光、自发光 GI 和最终合成的 Lightmap 分别准备缓存. 烘焙:依次烘焙主光、天光、自发光 GI,每步结果都存入缓存. 合成 Lightmap:把三步烘焙的结果合成一张最终 Lightmap. 替换旧 Lightmap:用新合成的 Lightmap 覆盖场景原有的光照贴图. 重置场景光照环境:修改场景设置. 更新全局参数:同步参数到所有相关材质. 烘焙反射探头:让反射效果也能正确显示. 核心代码 # public void MultiBake() { var buffer = new LightmapsBuffer(); Bake(BakeMode.BakeMainLight); var info = new LightmapsInfo(LightmapSettings.lightmaps); buffer.WriteBuffer(info, LightmapsBuffer.BufferType.MainLight); Bake(BakeMode.BakeSkyLight); buffer.WriteBuffer(info, LightmapsBuffer.BufferType.SkyLight); Bake(BakeMode.BakeEmissionGI); buffer.WriteBuffer(info, LightmapsBuffer.BufferType.EmissionGI); buffer.CreateLightmaps(); buffer.OverrideLightmaps(info); buffer.Clear(); ArrangeBakeScene(BakeMode.Default); UpdateGlobalProperties(); BakeReflectProbe(); } LightingController # 类, 继承与生命周期 # public class LightingController : MonoBehaviour 术语 说明 class 可以理解为\u0026quot;蓝图\u0026quot;,比如 Shader 是蓝图,Material 是根据蓝图做出来的\u0026quot;物品\u0026quot; 继承(inheritance) 比如\u0026quot;载具\u0026quot;是父类,\u0026ldquo;小轿车\u0026quot;是子类,子类自动拥有父类的基本功能 MonoBehaviour Unity 所有能挂在物体上的脚本都要继承它,才能参与游戏生命周期 [ExecuteInEditMode] 一般情况下,脚本只会在 PlayMode 下运行,这个指令让脚本在预览窗口也会运行 private void OnEnable() {UpdateGlobalProperties();}; 术语 说明 void 不同于之前案例的方法,void 类函数不返回值,它主要用于执行特定操作. OnEnable 意味着这个函数在游戏生命周期的 OnEnable 阶段开始运行 UpdateGlobalProperties() 的方法写在 OnEnable 后面,这在C#是允许的\nLightmapsInfo # 要了解以下概念,才能理解 LightmapsInfo 的作用\nLightmapData, 结构体、构造函数、Dictionary(字典) 和 foreach 循环\nLightmapData # LightmapData[] 是 Unity 的数据类型,它是当前场景所有光照贴图的集合 lightmapsData 是自定义名称,代表LightmapData[], 用于函数内部操作 LightmapsData[] 里面包含多个实例,每个实例代表每张 Lightingmap, 每个实例包含: lightmapColor, lightmapDir, shadowMask, occlusionMask 结构体 # struct 可以理解为一个\u0026quot;容器\u0026rdquo;,里面可以装不同类型的数据.\n语法: public/private 名称 (和 class/struct 同名) (类型,参数名)\n构造函数 # 用来初始化结构体 (或类) 的特殊函数,名字和结构体同名.\n示例 # public struct LightmapsInfo { public readonly Dictionary\u0026lt;string, Texture2D\u0026gt; lightmapsInfo; public LightmapsInfo(LightmapData[] lightmapsData) { // 这里会自动初始化所有内容 } } public class Person { public string Name; public int Age; // Constructor public Person(string name, int age) { Name = name; Age = age; } } 如果没有构造函数,你需要手动一项项赋值,非常繁琐. 有了构造函数,只需 new LightmapsInfo(参数),所有内容自动安排好. 构造函数的多种用法 # 构造函数可以有多个,参数不同或方法不同即可. 还可以在构造函数里做参数检查,防止出错. 示例 # public LightmapsInfo(LightmapData[] lightmapsData){ if(lightmapsData == null) { // 做一些容错处理 } // 其他初始化内容 } Dictionary(字典) # Dictionary 是一种\u0026quot;键值对\u0026quot;容器,可以通过\u0026quot;名字\u0026quot;快速找到对应的内容. 例如:Dictionary\u0026lt;string, Texture2D\u0026gt;,可以用字符串名字查找对应的贴图路径和对象. 案例 # Dictionary\u0026lt;string, Texture2D\u0026gt; myDict = new Dictionary\u0026lt;string, Texture2D\u0026gt;(); myDict[\u0026#34;MainLight\u0026#34;] = mainLightTex; Texture2D tex = myDict[\u0026#34;MainLight\u0026#34;]; foreach 循环 # foreach 用于遍历集合 (如数组、List、Dictionary 等)\n示例 # //data 代表实例 foreach (var data in lightmapsData) { var texture = data.lightmapColor; path = AssetDatabase.GetAssetPath(texture); lightmapsInfo.Add(path, texture); } int[] numbers = { 1, 2, 3, 4, 5 }; foreach (int num in numbers){ Debug.Log(num); // 输出:1, 2, 3, 4, 5 } LightmapsBuffer # 在 Unity 的光照烘焙流程中,我们需要对不同类型的光照贴图进行缓存、合成和保存.\n缓存的作用与实现 # 缓存 (Buffer) # 可以理解为\u0026quot;存储箱\u0026quot;,用来临时保存不同类型的光照贴图,方便后续处理和传递.\n枚举 (enum) # 用来定义一组常量,让代码更清晰易懂.\npublic enum BufferType { MainLight, // 主光光照:BufferA SkyLight, // 天光光照:BufferB EmissionGI, // 自发光 GI: BufferC Lightmap // 最终合成 } // 分别为不同类型的光照创建缓存 private Texture2D[] _bufferA; // 主光 private Texture2D[] _bufferB; // 天光 private Texture2D[] _bufferC; // 自发光 private Texture2D[] _lightmap; // 最终合成 ClearBuffer\u0026amp;Clear # 这两个方法会把对应或全部缓存清空\nswitch-case: 根据不同类型 (BufferType),执行不同的清理逻辑.\nvoid(类型 参数名):\n如果是单个数据,参数名就是这个数据在函数内的临时名称 如果是集合,参数名就是这个集合在函数内的临时名称 如果是 enum, 参数名就是 enum 内元素的临时名称. WriteBuffer # 此方法根据模式写入指定缓存\n先判断类型,若是最终 Lightmap 则直接返回. 清理对应类型的缓存. 创建新缓存,并从 info 中复制纹理. if (type == BufferType.Lightmap) return; // 清理缓存 ClearBuffer(type); // 创建缓存并从 info 复制纹理 var lightmapsCount = info.lightmapsCount; var buffer = new Texture2D[lightmapsCount]; for (var i = 0; i \u0026lt; lightmapsCount; i++) { var lightmap = info.lightmapsInfo.Values.ElementAt(i); buffer[i] = new Texture2D(lightmap.width, lightmap.height, lightmap.format, false); Graphics.CopyTexture(lightmap, 0, 0, buffer[i], 0, 0); } info.lightmapsInfo.Values.ElementAt(i):从字典中按顺序取出第 i 个贴图.\nTexture2D(纹理宽度,高度,格式(默认RGB24),是否生成mipmap)\nGraphics.CopyTexture:Unity API,用于高效复制贴图数据.\nCreateLightmaps # 依次读取主光、天光、自发光三种缓存的像素,合成到一张新的 Lightmap 上.\nfor (var x = 0; x \u0026lt; width; x++) { for (var y = 0; y \u0026lt; height; y++) { var colA = _bufferA[i].GetPixel(x, y); var colB = _bufferB[i].GetPixel(x, y); var colC = _bufferC[i].GetPixel(x, y); var newCol = new Color(colA.r, colB.g, colC.b, 1.0f); lightmap.SetPixel(x, y, newCol.linear); } } 每个像素点都从三张缓存贴图中取出对应颜色,合成到最终 Lightmap. 注意:缓存保存的是 Texture2D 对象,需要逐像素读取和写入. OverrideLightmaps # 将合成好的 Lightmap 编码为 EXR 格式 (支持 HDR),并写入磁盘. 刷新 Unity 资源数据库,让新文件被识别. for (var i = 0; i \u0026lt; lightmapsCount; i++) { var bytes = _lightmap[i].EncodeToEXR(Texture2D.EXRFlags.CompressZIP); File.WriteAllBytes(lightmapsInfo.Keys.ElementAt(i), bytes); AssetDatabase.Refresh(); } API/方法 说明 EncodeToEXR Unity API,将贴图编码为 EXR 格式,EXR 是 Unity 光照系统专用的格式 Texture2D.EXRFlags.CompressZip 压缩为 zip File.WriteAllBytes .NET API,将字节数组写入文件 lightmapsInfo.Keys.ElementAt(i) 从 dictionary lightmapsInfo 获取第 i 个 key,即路径 AssetDatabase.Refresh() 刷新资源数据库 (仅编辑器模式下可用) BakeMode\u0026amp;ArrangeBakeScene # BakeMode:用枚举定义不同的烘焙模式 (全部、主光、天光、自发光).\nArrangeBakeScene:根据不同模式设置场景参数,如环境光类型和强度.\nRenderSettings.ambientMode = AmbientMode.Skybox; RenderSettings.ambientIntensity = 1.0f; API/方法 说明 ambientMode 决定环境光类型 (天空盒、渐变、单色). ambientIntensity 控制环境光强度 (烘焙后生效). 对应 lightingSetting → lighting → Scene → Environment Lighting → Source \u0026amp; Intensity Multiplier\n设置主光为静态:\nvar staticFlags = StaticEditorFlags.ContributeGI | StaticEditorFlags.ReflectionProbeStatic; GameObjectUtility.SetStaticEditorFlags(mainlight.gameObject, staticFlags); Bake\u0026amp;BakeReflectProbe # Bake 直接调用 Unity API 进行光照烘焙.\npublic void Bake(BakeMode mode) { Lightmapping.Clear(); Lightmapping.Bake(); } BakeReflectProbe遍历场景所有反射探头,逐个烘焙并保存.\nprivate void BakeReflectProbe() { var allProbe = FindObjectsOfType\u0026lt;ReflectionProbe\u0026gt;(); foreach (var probe in allProbe) { var path = AssetDatabase.GetAssetPath(probe.texture); Lightmapping.BakeReflectionProbe(probe, path); } AssetDatabase.Refresh(); } API/方法 说明 FindObjectsOfType\u0026lt;\u0026gt;() 查找场景中所有反射探头 AssetDatabase.GetAssetPath() 获取这些反射探头的贴图和路径 Lightmapping.BakeReflectionProbe() Unity API,烘焙反射探头 如果不自定义存储路径的话,反射探头烘焙出来的 Cubemap 默认存在 LightingData 中\nLightingControllerGUI # 在了解了烘焙流程和方法后,我们还需要一个自定义的 UI 面板,让烘焙操作和参数调整更加直观.下面介绍 LightingControllerGUI 的实现思路和关键代码.\n编辑器类 # 类/方法 说明 UnityEditor.Editor 自定义编辑器类必须继承自 Editor,并实现 OnInspectorGUI() 方法 OnInspectorGUI() 用于绘制 Inspector 面板的内容 public class LightingControllerGUI : Editor { public override void OnInspectorGUI() { var controller = target as LightingController; if (controller == null) return; DrawFunctionButtons(controller); DrawGlobalProperties(controller); } } 术语/方法 说明 override 当 class 中的方法被设定为 virtual 或 abstract, 只能用 override 引用并重写执行的内容 target as LightingController 获取当前 Inspector 绑定的对象,必须是 MonoBehaviour 派生类 DrawFunctionButtons 绘制烘焙相关的操作按钮 DrawGlobalProperties 绘制全局参数的调节控件 功能的绘制 # 使用 GUILayout.Button(\u0026quot;按钮名称\u0026quot;) 创建按钮,点击后执行对应方法. EditorGUILayout.BeginHorizontal() 和 EndHorizontal() 用于让多个按钮在同一行显示. if (GUILayout.Button(\u0026#34;禁术·多重烘培\u0026#34;)) controller.MultiBake(); EditorGUILayout.BeginHorizontal(); // 可以在这里添加更多按钮 EditorGUILayout.EndHorizontal(); 参数的调节与监听 # 使用 EditorGUILayout.BeginFoldoutHeaderGroup 创建可折叠的参数组. 用 EditorGUILayout.Slider 创建可拖拽的滑块,方便调整参数. 用 EditorGUI.BeginChangeCheck() 和 EndChangeCheck() 监听参数变化,变化时自动更新. EditorGUI.BeginChangeCheck(); _groupAToggle = EditorGUILayout.BeginFoldoutHeaderGroup(_groupAToggle, \u0026#34;材质属性\u0026#34;); if (_groupAToggle) //等价于 if (groupAToggle == true) { controller.metalDarken = EditorGUILayout.Slider( \u0026#34;金属压暗\u0026#34;, controller.metalDarken, 0.0f, 5.0f); } EditorGUILayout.EndFoldoutHeaderGroup(); if (EditorGUI.EndChangeCheck()) { controller.UpdateGlobalProperties(); EditorUtility.SetDirty(controller); } _groupAToggle:用于控制折叠组的展开/收起,未赋值时默认为 false. EditorUtility.SetDirty(controller):标记对象为\u0026quot;已修改\u0026quot;,确保参数变动能被 Unity 记录. EmissionShaderGUI # 通过自定义 ShaderGUI,我们可以让材质球的 Inspector 面板出现\u0026quot;开启自发光 GI\u0026quot;的选项,方便控制自发光是否参与全局光照 (GI).\n继承ShaderGUI # 自定义材质 Inspector 面板时,需要继承 ShaderGUI 类.\npublic class EmissionShaderGUI : ShaderGUI { // 具体实现见下方 } 继承后,Unity 会自动获取使用该脚本的 Shader 和 Material 信息.\n获取当前材质 # 通过 materialEditor.target as Material 获取当前正在编辑的材质实例.\nvar material = materialEditor.target as Material; 默认界面 # 如果不需要自定义复杂的 UI,可以直接调用基类的 OnGUI,这样会显示默认的属性面板.\nbase.OnGUI(materialEditor, properties); 自发光GI开关 # 使用 EditorGUILayout.Toggle 创建一个勾选框,控制自发光是否参与全局光照.\nToggle 有 4 个参数, label, value, style, option, 对应文本内容, 条件, 按键风格, 按键尺寸\nvar ifEmissionGIOn = EditorGUILayout.Toggle( \u0026#34;开启自发光 GI\u0026#34;, material.globalIlluminationFlags == MaterialGlobalIlluminationFlags.AnyEmissive); material.globalIlluminationFlags = ifEmissionGIOn ? MaterialGlobalIlluminationFlags.AnyEmissive : MaterialGlobalIlluminationFlags.EmissiveIsBlack; EditorGUILayout.Toggle(\u0026quot;界面文本\u0026quot;, 条件):根据条件显示勾选状态. 三元运算符 条件 ? 结果A : 结果B,等价于 if-else 语句: if (ifEmissionGIOn) material.globalIlluminationFlags = MaterialGlobalIlluminationFlags.AnyEmissive; else material.globalIlluminationFlags = MaterialGlobalIlluminationFlags.EmissiveIsBlack; Shader部分讲解 # 在本案例中,Shader 与其他案例相比有以下几个关键差别:\nLightmap UV 的计算方式 MetaPass 的实现 分支声明 (shader_feature) ShadowCaster 的自定义 LightmapUV # 在 Unity 中,Lightmap 的 UV 坐标通常这样计算:\nfloat2 lmUV = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw; uv1 是模型的第二套 UV(专门用于光照贴图). unity_LightmapST 是 Unity 自动传入的缩放/偏移参数. MetaPass # MetaPass 是 Unity 光照烘焙系统专用的 Shader 通道.只有带有 MetaPass 的 Shader 才能参与到光照烘焙.\n案例代码 # //Building.Shader 的 MetaPass Pass { Name \u0026#34;META\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;Meta\u0026#34; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;UnityMetaPass.cginc\u0026#34; #pragma shader_feature __ _BAKE_MAINLIGHT _BAKE_SKYLIGHT _BAKE_EMISSIONGI struct VertexInput { float4 vertex : POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float2 uv2 : TEXCOORD2; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; VertexOutput vert (VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityMetaVertexPosition(v.vertex, v.uv1, v.uv2, unity_LightmapST, unity_DynamicLightmapST); o.uv = v.uv0; return o; } float4 frag(VertexOutput i) : COLOR { UnityMetaInput metaIN; UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN); metaIN.Albedo = Luminance(tex2D(_MainTex, i.uv).rgb); metaIN.SpecularColor = 0.0f; metaIN.Emission = 0.0f; return UnityMetaFragment(metaIN); } ENDCG } 要点说明 # UnityStandardMeta.cgnic PBR 流程 META Pass 专用 UnityMetaPass.cginc 属于UnityStandardMeta.cgnic的一部分,由于案例不是 PBR 流程,出于优化的考虑,只引用该 cginc. 相比 UnityStandardMeta.cgnic需要自定义顶点着色器部分 UnityMetaVertexPosition:将顶点和 UV 转换到烘焙空间. UnityMetaInput:包含 Albedo、SpecularColor、Emission 等烘焙所需数据的数组. UNITY_INITIALIZE_OUTPUT初始化UnityMetaInput Luminance:将颜色转为灰度,保证烘焙时只考虑明暗,不受高光和自发光影响. 分支控制 # //LightingController.cs ... case BakeMode.Default: // 关闭主光 mainlight.enabled = true; // 设置环境 RenderSettings.ambientMode = AmbientMode.Skybox; RenderSettings.ambientIntensity = 1.0f; // 设置 Shader 全局分支 Shader.DisableKeyword(\u0026#34;_BAKE_MAINLIGHT\u0026#34;); Shader.DisableKeyword(\u0026#34;_BAKE_SKYLIGHT\u0026#34;); Shader.DisableKeyword(\u0026#34;_BAKE_EMISSIONGI\u0026#34;); break; ... #pragma shader_feature __ _BAKE_MAINLIGHT _BAKE_SKYLIGHT _BAKE_EMISSIONGI 需要在脚本和 Shader 设置全局分支 通过分支声明,可以让 Shader 针对不同烘焙模式输出不同内容. 在代码中用 #if defined(...) 进行分支判断: #if defined (_BAKE_EMISSIONGI) metaIN.Emission = opacity; #elif defined (_BAKE_MAINLIGHT) || defined (_BAKE_SKYLIGHT) metaIN.Emission = 0.0f; #endif Skybox 特殊说明 # Skybox 的 Shader 不需要 MetaPass,Unity 内部会自动处理天空盒的光照烘焙. ShadowCaster # 由于本案例场景是非封闭盒状,且法线朝内,Unity 默认的 ShadowCaster 不能正确投影.需要自定义 ShadowCaster Pass.\n案例代码 # Pass { Name \u0026#34;ShadowCaster\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ShadowCaster\u0026#34; } ZWrite On ZTest LEqual Cull off CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f { V2F_SHADOW_CASTER; }; v2f vert(appdata_base v) { v2f o; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } 要点说明 # appdata_base:Unity 预定义的顶点输入结构,包含 POSITION、NORMAL、TEXCOORD0. V2F_SHADOW_CASTER:输出结构,包含投影所需的裁剪空间位置和辅助向量,等价于: float4 pos : SV_POSITION; float3 vec : TEXCOORD0; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o):计算投影偏移,保证投影正确. TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) float4 clipPos = UnityClipSpaceShadowCasterPos(v.vertex, v.normal); \\ o.pos = UnityApplyLinearShadowBias(clipPos); \\ o.vec = ComputeOffsetData(clipPos); SHADOW_CASTER_FRAGMENT(i) Unity 内置宏,在片段着色器中计算阴影投射 Cull off:关闭剔除,保证内表面也能投影. uv0: TEXCOORD0 在 VertexInput 里会自动识别为模型的第一套 UV, 在 VertexOutput, TEXCOORD0 就是通用插值寄存器,是开发者自定义的数据通道,需要在 vert 中手动从输入数据计算并赋值\n","date":"2025-05-31","externalUrl":null,"permalink":"/zh-cn/notes/courses/zhuangdongcourse/lightingmap/","section":"笔记","summary":"","title":"庄懂的技术美术入门课 - 光照贴图","type":"notes"},{"content":" 13 透明特效相关的多种模式 # 常用模式 # 混合模式 用途 优点 缺点 透混 AB (AlphaBlend) 复杂轮廓、无明确边缘的物体\n半透明物体\n一般特效打底 移动端性能较好\n边缘效果自然 有排序问题 透叠 AD (Additive) 发光体、辉光表现\n特效提亮 - 有排序问题\n多层叠加易 OverDraw\n作为辉光效果,通常可用后处理代替 透切 AC (AlphaCutOut) 复杂轮廓、明确边缘 (如树叶、头发、金属镂空)\n卡通特效 (配合抗锯齿) 无排序问题 边缘生硬\n移动端性能较差 自定义模式 # 自定义混合公式,灵活实现特殊效果, 需要遵循特定语法\n语法 # Src * SrcFactor op Dst * DstFactor 元素 说明 Src 源,当前 Shader 绘制结果 Dst 目标,当前 Shader 绘制前的背景 SrcFactor 源乘子 DstFactor 目标乘子 op 混合运算符 乘子决定相关元素以什么方式参与混合,混合运算符决定混合的形式,详细内容请查阅 Unity 官方文档\n代码案例 # //AB案例 Shader \u0026#34;Zhuangdong/AP1/L07/L07_AB\u0026#34; { Properties{ _MainTex (\u0026#34;RGB: 颜色 A: 透贴\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Opacity (\u0026#34;透明度\u0026#34;, range(0,1)) = 0.5 } SubShader{ Tags { \u0026#34;Queue\u0026#34; = \u0026#34;Transparent\u0026#34; //让透明物体最后渲染,防止出现后面物体消失的现象 \u0026#34;RenderType\u0026#34; = \u0026#34;Transparent\u0026#34; \u0026#34;ForceNoShadowCasting\u0026#34; = \u0026#34;True\u0026#34;//关闭投影 \u0026#34;IgnoreProject\u0026#34; = \u0026#34;True\u0026#34;//不影响投射器 } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } Blend One OneMinusSrcAlpha//声明混合方式 CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #pragma multi_compile_fwdbase_fullshadows #pragma target 3.0 uniform sampler2D _MainTex; uniform float4 _MainTex_ST; uniform half _Opacity; struct VertexInput { float4 vertex : POSITION; float2 uv0 : TEXCOORD0; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); return o; } half4 frag(VertexOutput i) : COLOR{ //固定写法 half4 var_MainTex = tex2D(_MainTex, i.uv0); half3 finalRGB = var_MainTex.rgb; half opacity = var_MainTex.a * _Opacity; return half4(finalRGB * opacity, opacity); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } //AD案例 //以 AB 案例为模板 ... SubShader{ ... pass{ ... Blend One One //只需要把 AB 案例的 BlendMode 修改即可 ... } ... } //AC案例 //以 AB 案例为模板 ... SubShader{ Tags{ \u0026#34;RenderType\u0026#34; = \u0026#34;TransparentCutout\u0026#34;//对应 AC \u0026#34;ForceNoShadowCasting\u0026#34; = \u0026#34;True\u0026#34; \u0026#34;IgnoreProject\u0026#34; = \u0026#34;True\u0026#34; } pass{ ... half4 frag(VertexOutput i) : COLOR{ half4 var_MainTex = tex2D(_MainTex, i.uv0); half opacity = var_MainTex.a; clip(opacity - _Cutoff);//透明剪切 return half4(var_MainTex.rgb, 1.0); } } ... } //自定义案例 ... Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } BlendOp [_BlendOp] Blend [_BlendSrc] [_BlendDst] //在 Tags 后添加公式 ... 15 常见问题 # 1. 排序问题 # 透明物体渲染时,前后关系不明确\n解决方法 # Detach/Attach(DDC软件修改模型顶点顺序) ZWrite Off(关闭深度写入) 2. 贴图预乘问题 # 有的贴图资产已做预乘 (BaseColor * Alpha),有的没有,混合方式需区分\nAB 模式:预乘用 One OneMinusSrcAlpha,不预乘用 SrcAlpha OneMinusSrcAlpha, 或在 frag 做乘法 AD 模式:预乘可无 A 通道,不预乘需在 frag 做乘法 3. 案例 GhostFlow # //以 AB 为模板 Shader \u0026#34;Zhuangdong/AP1/L08/L08_GhostFlow\u0026#34; { Properties{ _MainTex (\u0026#34;RGB: 颜色 A: 透贴\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _Opacity (\u0026#34;透明度\u0026#34;, range(0,1)) = 0.5 _WarpTex (\u0026#34;扭曲图\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _WarpInt (\u0026#34;扭曲强度\u0026#34;, range(0, 1)) = 0.5 _NoiseInt(\u0026#34;噪声强度\u0026#34;, range(0, 5)) = 0.5 _FlowSpeed (\u0026#34;流动速度\u0026#34;, range(0, 10)) = 5 } SubShader{ ... Pass { ... Blend One OneMinusSrcAlpha ... struct VertexInput { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv; o.uv1 = TRANSFORM_TEX(v.uv, _WarpTex); //开启 Tiling o.uv1.y = o.uv1.y + frac(_Time.x * _FlowSpeed);//启动 V 轴流动 return o; } half4 frag(VertexOutput i) : COLOR{ half3 var_WarpTex = tex2D(_WarpTex, i.uv1); half2 uvBias = (var_WarpTex.rg - 0.5) * _WarpInt; half2 uv0 = i.uv0 + uvBias; half4 var_MainTex = tex2D(_MainTex, uv0); half3 finalRGB = var_MainTex.rgb; half noise = lerp(1.0, var_WarpTex.b * 2.0, _NoiseInt); noise = max(0.0, noise); half opacity = var_MainTex.a * _Opacity * noise; return half4(finalRGB * opacity, opacity); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 核心思路 # 通过扰动贴图和流动速度参数,实现透明特效的动态变化\no.uv1.y = o.uv1.y + frac(_Time.x * _FlowSpeed); // V 轴流动 half opacity = var_MainTex.a * _Opacity * noise; 参数/函数 说明 _Time 随时间递增的参数,有 x,y,z,w 四个分量,代表不同速度挡位 _FlowSpeed 控制流动速度 frac 取余,这里是为了防止_Time 无限增长导致出现摩尔纹 noise = lerp(1.0, var_WarpTex.b * 2.0, _NoiseInt) 保证明度不变暗 _NoiseInt 此参数数值越高,noise 越清晰,超过 1 时,noise 对比度加强 max(0.0, noise) 防止出现负值导致颜色异常 4. 案例 GhostWarp # //以 GhostFlow 为模板 ... half3 var_WarpTex = tex2D(_WarpTex, i.uv1); half2 uvBias = (var_WarpTex.rg - 0.5) * _WarpInt; half2 uv0 = i.uv0 + uvBias; half4 var_MainTex = tex2D(_MainTex, uv0); ... 原理 # WarpTex 的 rg 通道控制 UV 扰动方向,-0.5 保证扰动均匀分布\n注意 # WarpInt 过大时,扰动会很突兀.这是明暗两边灰度值差异过大导致的\n14, 16 火焰与水波纹特效案例 # 火焰特效 # 关键代码 # //以 GhostFlow 为模板 Shader \u0026#34;Zhuangdong/AP1/L09/L09_Fire\u0026#34; { Properties{ _Mask (\u0026#34;R:外焰 G:内焰 B:透贴\u0026#34;, 2D) = \u0026#34;blue\u0026#34; {} _Noise (\u0026#34;R:Noise1 G:Noise2\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _Noise1Params (\u0026#34;Noise1 x:大小 y:流速 z:强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) _Noise2Params (\u0026#34;Noise2 x:大小 y:流速 z:强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) _color1 (\u0026#34;外焰颜色\u0026#34;, Color) = (1,1,1,1) _color2 (\u0026#34;内焰颜色\u0026#34;, Color) = (1,1,1,1) } SubShader{ ... Pass { ... Blend One OneMinusSrcAlpha ... struct VertexInput { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float2 uv2 : TEXCOORD2; }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv; o.uv1 = v.uv * _Noise1Params.x - float2(0.0, frac(_Time.x * _Noise1Params.y)); o.uv2 = v.uv * _Noise2Params.x - float2(0.0, frac(_Time.x * _Noise2Params.y)); return o; } half4 frag(VertexOutput i) : COLOR{ half warpMask = tex2D(_Mask, i.uv0).b; half var_Noise1 = tex2D(_Noise, i.uv1).r; half var_Noise2 = tex2D(_Noise, i.uv2).g; half noise = var_Noise1 * _Noise1Params.z + var_Noise2 * _Noise2Params.z; float2 warpUV = i.uv0 - float2(0.0, noise) * warpMask; half3 var_Mask = tex2D(_Mask, warpUV); half3 finalRGB = _color1 * var_Mask.r + _color2 * var_Mask.g; half opacity = var_Mask.r + var_Mask.g; return half4(finalRGB, opacity); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 原理 # 两层 Noise 扰动叠加,控制火焰动态,同时通过 mask 自定义内焰外焰的颜色\n关键点 # 参数/表达式 说明 _NoiseParams.x 控制 Tiling _NoiseParams.y 控制速度 _NoiseParams.z 控制扰动强度 float2(0,0, frac()) 如果 v.uv - frac() 的话,纹理会往对角线方向流动,因为 frac 会自动识别为 float2(frac(), frac()) 水波纹特效 # 关键代码 # //以 Fire 为模板 Shader \u0026#34;Zhuangdong/AP1/L09/L09_Water\u0026#34; { Properties{ _MainTex (\u0026#34;颜色贴图\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _WarpTex (\u0026#34;扰动图\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _Speed (\u0026#34;x: 流速 x y: 流速 y\u0026#34;, vector) = (1.0, 1.0, 0.5, 1.0) _Warp1Params (\u0026#34;Noise1 x: 大小 y: 流速 x z: 流速 y w: 强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) _Warp2Params (\u0026#34;Noise2 x: 大小 y: 流速 x z: 流速 y w: 强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) } SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } ... VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv - frac(_Time.x * _Speed);//主贴图流动 o.uv1 = v.uv * _Warp1Params.x - frac(_Time.x * _Warp1Params.yz);//扰动贴图 1 流动 o.uv2 = v.uv * _Warp2Params.x - frac(_Time.x * _Warp2Params.yz);//扰动贴图 2 流动 return o; } float4 frag(VertexOutput i) : COLOR{ half3 var_Warp1 = tex2D(_WarpTex, i.uv1).rgb;//扰动值 1 half3 var_Warp2 = tex2D(_WarpTex, i.uv2).rgb;//扰动值 2 half2 warp = (var_Warp1.xy - 0.5) * _Warp1Params.w + (var_Warp2.xy - 0.5) * _Warp2Params.w; float2 warpUV = i.uv0 + warp;//添加扰动值 half4 var_MainTex = tex2D(_MainTex, warpUV); return float4(var_MainTex.xyz, 1.0); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 原理 # 主纹理 UV 加上两层扰动 Noise,实现水面波动效果\n17 ScreenUV\u0026amp;ScreenWarp # ScreenUV # 通过屏幕空间 UV 采样,实现纹理随摄像机距离变化和流动的特效.\n关键在于用视空间坐标矫正畸变,并叠加流动效果.\n关键代码 # //以 AB 为模板 ... VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.uv; float3 posVS = UnityObjectToViewPos(v.vertex).xyz;//顶点位置 OS 转 VS o.screenUV = posVS.xy / posVS.z;//VS 空间畸变矫正 float originDist = UnityObjectToViewPos(float3(0.0, 0.0, 0.0)).z;//原点位置 o.screenUV *= originDist; //o.screenUV * originDist o.screenUV = o.screenUV * _ScreenTex_ST.xy - frac(_Time.x * _ScreenTex_ST.zw);//增加 tiling 和 offset 和 流动 return o; } half4 frag(VertexOutput i) : COLOR{ half4 var_MainTex = tex2D(_MainTex, i.uv); half var_ScreenTex = tex2D(_ScreenTex, i.screenUV).r; half3 finalRGB = var_MainTex.rgb; half opacity = var_MainTex.a * _Opacity * var_ScreenTex; return half4(finalRGB * opacity, opacity); } ... 要点 # o.screenUV 视空间矫正 UV,防止深度畸变 originDist 通过原点距离控制纹理缩放. time 叠加流动效果. ScreenWarp # 利用 GrabPass 获取背景,通过主纹理的某个通道扰动屏幕 UV,实现半透明区域的背景扭曲 (类似 PS 正片叠底)\n关键代码 # Shader \u0026#34;Zhuangdong/AP1/L10/L10_ScreenWarp\u0026#34; { Properties{ _MainTex (\u0026#34;RGB: 颜色 A: 透贴\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Opacity (\u0026#34;透明度\u0026#34;, range(0,1)) = 0.5 _WarpMidVal (\u0026#34;扭曲中间值\u0026#34;, range(0, 1)) = 0.5 _WarpInt (\u0026#34;扭曲强度\u0026#34;, range(0, 3)) = 0.2 } SubShader{ ... GrabPass{ \u0026#34;_BGTex\u0026#34; } ... uniform sampler2D _BGTex; ... struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float4 grabPos : TEXCOORD1;//背景采样坐标 }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); o.grabPos = ComputeGrabScreenPos(o.pos);//针对 grabpass 的背景纹理采样坐标 return o; } half4 frag(VertexOutput i) : COLOR{ half4 var_MainTex = tex2D(_MainTex, i.uv0); i.grabPos.xy += (var_MainTex.b - _WarpMidVal) * _WarpInt * _Opacity; half3 var_BGTex = tex2Dproj(_BGTex, i.grabPos); //tex2Dproj 是专门采样这类贴图的指令 half3 finalRGB = var_MainTex.rgb * var_BGTex; half opacity = var_MainTex.a * _Opacity; return half4(finalRGB * opacity, opacity); ... 要点 # GrabPass 获取背景并保存在 BGTex 中 WarpMidVal 调整 UV 采样位置 _Opacity 透明度和 i.grabPos 绑定,透明度越低,扭曲越明显 同类方法 # GrabPass: 适合高质量但性能开销大 CommandBuffer: 前 Srp 时代管线自定义方法 Lwrp/Urp: 后 Srp 时代管线自定义方法 (推荐) 18. 序列帧动画 (Sequence) # 序列帧动画原理 # 在特效制作中,常用一张包含多帧的序列帧贴图,每一帧代表动画的一个状态.通过切换 UV 采样区域,实现动画播放效果.\n案例贴图为 3 行 4 列,每帧依次排列. 特效层悬浮于物体表面 (通过顶点沿法线方向挤出). UV 起点为左上,需调整初始采样区域. 关键代码 # //在 AB 案例基础上添加一个 pass ... pass{ Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } Blend One One ... VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; //顶点沿法线方向挤出 v.vertex.xyz += v.normal * 0.01; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _Sequence); //计算当前帧索引 float id = floor(_Time.z * _Speed); float idV = floor(id / _ColCount); float idU = id - idV * _ColCount; float stepU = 1.0 / _ColCount; float stepV = 1.0 / _RowCount; //uv 缩放并调整起点到左上 float2 initUV = o.uv * float2(stepU, stepV) + float2(0.0, stepV * (_RowCount -1)); o.uv = initUV + float2(idU * stepU, -idV * stepV); return o; } half4 frag(VertexOutput i) : COLOR{ half4 var_Sequence = tex2D(_Sequence, i.uv); half3 finalRGB = var_Sequence.rgb; half opacity = var_Sequence.a; return half4(finalRGB * opacity, opacity); } ENDCG ... 要点总结 # floor向下取整,比如 1.9 输出 1 id 横向每次移动 1/_ColCount idV = floor(id / _ColCount) 当 id 为列数的整数倍时,idV 增加 1 idU = id - idV * _ColCount纵向每满一行移动 1/_RowCount, 同时 idU 清零 float2(idU * stepU, -idV * stepV)每次移动1/_ColCount单位,当移动次数等于_ColCount时,idU清零回到最左边,同时纵向移动1/_RowCount单位 注:特效算法尽量简单,避免 overdraw.\n极坐标动画 (PolarCoord) # 极坐标变换可实现径向流动、扫描等特效.通过将 UV 从笛卡尔坐标系转换为极坐标,并叠加时间流动,实现特殊动画效果.\n极坐标 # 假设一个 x 轴,原点到点 M 连接,OM 和 x 轴夹角为θ,OM 长度为 P, 极坐标为 (θ, P)\n关键代码 # half4 frag(VertexOutput i) : COLOR { i.uv = i.uv - float2(0.5, 0.5); float theta = atan2(i.uv.y, i.uv.x); theta = theta / 3.1415926 * 0.5 + 0.5; float p = length(i.uv) + frac(_Time.x * 3); i.uv = float2(theta, p); half4 var_MainTex = tex2D(_MainTex, i.uv); half3 finalRGB = (1 - var_MainTex.rgb); half opacity = (1 - var_MainTex.r) * _Opacity * i.color.r; return half4(finalRGB * opacity, opacity); } 要点总结 # atan2 计算角度θ, 结果为 (-Π, Π), 归一化到[0,1]. length 计算点 (x, y) 到原点的距离,由于原点从 (0,0) 偏移到了 (0.5, 0.5), 输出的结果会是这样的 float2(theta, p)UV 映射到极坐标,实现径向动画. i.color 顶点色用于柔化边缘. 19. 顶点动画 (Vertex Animation) # 19.1 平移 (Translation) # 通过正弦函数让顶点在 Y 轴方向周期性移动,实现整体上下浮动效果.\n关键代码 # //以 AB 为模板 ... #define TWO_PI 6.283185 void Translation (inout float3 vertex) { vertex.y += _MoveRange * sin(frac(_Time.z * _MoveSpeed) * TWO_PI); } VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; Translation(v.vertex.xyz); o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; return o; } 要点 # frac FractionalPrat, 取小数部分,保证时间参数在[0,1]循环,防止溢出. sin sin(0, 2Π) 是一个从 0 到 1 再到 0 的周期运动. 19.2 缩放 (Scale) # 所有顶点按同一比例缩放.\n关键代码 # //以 AB 为模板 void Scaling (inout float3 vertex) { vertex.xyz *= 1.0 + _ScaleRange * sin(frac(_Time.z * _ScaleSpeed) * TWO_PI); } VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; Scaling(v.vertex.xyz); o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); return o; } 要点 # 保证缩放值大于 0,避免反向缩放.\n19.3 旋转 (Rotation) # 顶点绕 Y 轴周期性旋转,实现摇头、摆动等效果.\n关键代码 # //以 AB 为模板 void Rotation (inout float3 vertex) { float angleY = _RotateRange * sin(frac(_Time.z * _Rotatepeed) * TWO_PI); float radY = radians(angleY); float sinY, cosY = 0; sincos(radY, sinY, cosY); vertex.xz = float2( vertex.x * cosY - vertex.z * sinY, vertex.x * sinY + vertex.z * cosY ); } 要点 # radians 角度转弧度,弧度写法提升性能 sincos(raY, sinY, cosY) 等价于 sinY = sin(radY), cosY = cos(radY), 这种写法提高性能. vertex.xz 旋转矩阵 M (x * cosθ - y * sinθ, x * sinθ + y * cosθ) 19.4 复合动画 (AnimationGhost) # 将缩放、平移、旋转等多种动画结合,配合顶点色实现复杂运动 (如幽灵、天使圈等).\n关键代码 # ... //以 AB 为模板 void AnimGhost (inout float3 vertex, inout float3 color){ // 天使圈缩放 float scale = _ScaleParams.x * color.g * sin(frac(_Time.z * _ScaleParams.y) * TWO_PI); vertex.xyz *= 1.0 + scale; vertex.y -= _ScaleParams.z * -scale; // 幽灵摆动 float swingX = _SwingXparams.x * sin(frac(_Time.z * _SwingXparams.y + vertex.y * _SwingXparams.z) * TWO_PI); float swingZ = _SwingZparams.x * sin(frac(_Time.z * _SwingZparams.y + vertex.y * _SwingZparams.z) * TWO_PI); vertex.xz += float2(swingX, swingZ) * color.r; // 幽灵摇头 float radY = radians(_ShakeYparams.x) * (1.0 - color.r) * sin(frac(_Time.z * _ShakeYparams.y - color.g * _ShakeYparams.z) * TWO_PI); float sinY, cosY = 0; sincos(radY, sinY, cosY); vertex.xz = float2( vertex.x * cosY - vertex.z * sinY, vertex.x * sinY + vertex.z * cosY ); // 幽灵起伏 float swingY = _SwingYparams.x * sin(frac(_Time.z * _SwingYparams.y - color.g * _SwingYparams.z) * TWO_PI); vertex.y += swingY; // 处理顶点色 float lightness = 1.0 + color.g * 1.0 + scale * 2.0; color = float3(lightness, lightness, lightness); } ... 要点 # 使用顶点色 R、G 通道分别控制不同动画区域. vertex.y -= _ScaleParams.z * -scale 缩放动画是以模型原点为中心缩放的,控制 y 轴缩放幅度,避免天使圈离开原地 vertex.y * _SwingXparams.zsin 的的结果受 vertex.y 影响,实现 S 形摆动 _ShakeYoarams.z _SwingYparams.z让天使环和其他部分的动画,产生时间上的滞后 lightness 光环亮度随 time 变化 20. 时钟动画 (ClockAnim) # 20.1 时钟指针动画 # 通过C#脚本获取系统时间,驱动Shader中时针、分针、秒针的旋转,实现真实时钟动画.\n关键代码 # ... void RotateZwithOffset(float angle, float offset, float mask, inout float3 vertex){ vertex.y -= offset * mask; float radZ = radians(angle * mask); float sinZ, cosZ = 0; sincos(radZ, sinZ, cosZ); vertex.xy = float2( vertex.x * cosZ - vertex.y * sinZ, vertex.x * sinZ + vertex.y * cosZ ); vertex.y += offset * mask; } void ClockAnim(float3 color, inout float3 vertex) { RotateZwithOffset(_HourHandAngle, _RotateOffset, color.r, vertex); RotateZwithOffset(_MinuteHandAngle, _RotateOffset, color.g, vertex); RotateZwithOffset(_SecondHandAngle, _RotateOffset, color.b, vertex); } VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; ClockAnim(v.color.rgb, v.vertex.xyz); ... 要点 # angle 代表每个时间单位的旋转角度 offset 偏移旋转中心.初始中心在模型原点,需要调整 C#脚本绑定系统时间 # using System; using UnityEngine; public class HelloWorld : MonoBehaviour { // --------- Public ------- public Material clockMat; // --------- private -------- private bool valid; private int hourAnglePropID; private int minuteAnglePropID; private int secondAnglePropID; // Start is called before the first frame update void Start() { if(clockMat == null) return; hourAnglePropID = Shader.PropertyToID(\u0026#34;_HourHandAngle\u0026#34;); minuteAnglePropID = Shader.PropertyToID(\u0026#34;_MinuteHandAngle\u0026#34;); secondAnglePropID = Shader.PropertyToID(\u0026#34;_SecondHandAngle\u0026#34;); if(clockMat.HasProperty(hourAnglePropID) \u0026amp;\u0026amp; clockMat.HasProperty(minuteAnglePropID) \u0026amp;\u0026amp; clockMat.HasProperty(secondAnglePropID)) valid = true; Debug.Log(\u0026#34;hourAnglePropID\u0026#34; + hourAnglePropID); Debug.Log(\u0026#34;minuteAnglePropID\u0026#34; + minuteAnglePropID); Debug.Log(\u0026#34;secondAnglePropID\u0026#34; + secondAnglePropID); Debug.Log(valid); } // Update is called once per frame void Update() { if(!valid) return; int second = DateTime.Now.Second; float secondAngle = second /60.0f * 360.0f; clockMat.SetFloat(secondAnglePropID, secondAngle); int minute = DateTime.Now.Minute; float minuteAngle = minute /60.0f * 360.0f; clockMat.SetFloat(minuteAnglePropID, minuteAngle); int hour = DateTime.Now.Hour; float hourAngle = (hour % 12) / 12.0f * 360.0f + minuteAngle / 360.0f * 30.0f; clockMat.SetFloat(hourAnglePropID, hourAngle); } } 要点 # 继承 编程术语,可以让 class 直接使用其他 class 现存的方法\nclockMat 模型的材质,继承自MonoBehaviour的 class, 其脚本被允许附着在 GameObject 上,并获取该 GameObject 的材质\n% 取余,保证 hour 超过 12 时归 0\n余数 = 被除数 - (除数 * 整数商), 比如 7/3 的余数 = 7 - (3 * 2) = 1\n20.2 阴影投影 Pass # 关键代码 # Pass { Name \u0026#34;ShadowCaster\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ShadowCaster\u0026#34; } CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include \u0026#34;UnityCG.cginc\u0026#34; uniform float _HourHandAngle, _MinuteHandAngle, _SecondHandAngle, _RotateOffset; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float3 color : COLOR; }; struct v2f { V2F_SHADOW_CASTER; }; void RotateZwithOffset(float angle, float offset, float mask, inout float3 vertex){ vertex.y -= offset * mask; float radZ = radians(angle * mask); float sinZ, cosZ = 0; sincos(radZ, sinZ, cosZ); vertex.xy = float2( vertex.x * cosZ - vertex.y * sinZ, vertex.x * sinZ + vertex.y * cosZ ); vertex.y += offset * mask; } void ClockAnim(float3 color, inout float3 vertex) { RotateZwithOffset(_HourHandAngle, _RotateOffset, color.r, vertex); RotateZwithOffset(_MinuteHandAngle, _RotateOffset, color.g, vertex); RotateZwithOffset(_SecondHandAngle, _RotateOffset, color.b, vertex); } v2f vert(appdata v) { v2f o; ClockAnim(v.color.rgb, v.vertex.xyz); // 关键修复:计算带法线偏移的阴影坐标 float3 posWS = mul(unity_ObjectToWorld, v.vertex).xyz;//动画后的顶点转世界空间 float3 normalWS = UnityObjectToWorldNormal(v.normal);//法线转世界空间 o.pos = UnityClipSpaceShadowCasterPos(posWS, normalWS); TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } 要点 # ShadowCaster 处理投影 Pass 的固定命名,以及 LightMode 的固定模式\nUnityClipSpaceShadowCasterPos(posWS, normalWS) 法线偏移修正,获得动画前的法线和动画后的顶点,来计算动画后的法线方向,最终输出动画后的顶点位置和修正后的法线在光源视锥体下的裁剪空间坐标\nV2F_SHADOW_CASTER Unity 内置宏,等价于:\nfloat4 pos : SV_POSITION float3 vec : TEXCOORD0 (只在有点光源时使用) TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) 输入 posWS, normalWS, 输出V2F_SHADOW_CASTER\nSHADOW_CASTER_FRAGMENT(i) 输入 pos, 根据光源类型处理投影\n注:只需要 ShadowCaster, V2F_SHADOW_CASTER, TRANSFER_SHADOW_CASTER_NORMALOFFSET(o), SHADOW_CASTER_FRAGMENT(i) 4 个要素就能获得一个功能完整的阴影投射 Pass\n21. 特效消融动画案例 # 21.1 灰度图与噪声控制消融 # 通过多通道灰度图、噪声图、顶点色,实现网格消失、随机性、发光等复杂消融特效.\n关键结构体与函数 # struct VertexInput { float4 vertex : POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float4 normal : NORMAL; float4 tangent : TANGENT; float4 color : COLOR; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float4 posWS : TEXCOORD2; float3 nDirWS : TEXCOORD3; float3 tDirWS : TEXCOORD4; float3 bDirWS : TEXCOORD5; float4 effectMask : TEXCOORD6; LIGHTING_COORDS(7,8) }; float4 CyberpunkAnim(float noise, float mask, float3 normal, inout float3 vertex){ float baseMask = abs(frac(vertex.y * _EffParams.x - _Time.x * _EffParams.y) -0.5) * 2.0; baseMask = min(1.0, baseMask * 2.0); baseMask += (noise - 0.5) * _EffParams.z; float4 effectMask = float4(0.0, 0.0, 0.0, 0.0); effectMask.x = smoothstep(0.0, 0.9, baseMask); effectMask.y = smoothstep(0.2, 0.7, baseMask); effectMask.z = smoothstep(0.4, 0.5, baseMask); effectMask.w = mask; vertex.xz += normal.xz * (1.0 - effectMask.y) * _EffParams.w * mask; return effectMask; } 顶点着色器 # VertexOutput vert(VertexInput v) { float noise = tex2Dlod(_EffectMap02, float4(v.uv1, 0.0, 0.0)).r; VertexOutput o = (VertexOutput)0; o.effectMask = CyberpunkAnim(noise, v.color, v.normal.xyz, v.vertex.xyz); o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; o.uv1 = v.uv1; o.posWS = mul(unity_ObjectToWorld, v.vertex); o.nDirWS = UnityObjectToWorldNormal(v.normal); o.tDirWS = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz ); o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w); TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } 片段着色器 # float4 frag(VertexOutput i) : COLOR{ // ...(向量、光照、采样等略)... //光照模型 float3 baseCol = var_MainTex.rgb * _BaseColor; float Lambert = max(0.0, nDotl);//lambert float specCol = var_SpecTex.rgb; float specpow = lerp(1, _SpecularPow_Value, var_SpecTex.a); float Phong = pow(max(0.0, vDotr), _SpecularPow_Value); float shadow = LIGHT_ATTENUATION(i); float3 dirlighting = (baseCol * Lambert + specCol * Phong) * _LightColor0 * shadow; float3 EnvCol = TriColAmbient(nDirWS, _TopCol, _MidCol, _BotCol); float fresnel = pow(1.0 - ndotv, _FresnelPow); float occlusion = var_MainTex.a; float3 envLighting = (baseCol * EnvCol * _EnvDiffInt + var_Cubemap * fresnel* _EnvSpecint * var_SpecTex.a) * occlusion; //自发光 float3 emission = var_EmitTex * _EmitInt; float3 _EffectMap01_var = tex2D(_EffectMap01, i.uv1).xyz; float meshMask = _EffectMap01_var.x; float faceRandomMask = max(0.001, _EffectMap01_var.y); float faceSlopMask = max(0.001, _EffectMap01_var.z); float smallMask = i.effectMask.x; float midMask = i.effectMask.y; float bigMask = i.effectMask.z; float baseMask = i.effectMask.w; float midOpacity = saturate(floor(min(faceRandomMask, 0.999999) + midMask)); float bigOpacity = saturate(floor(min(faceSlopMask, 0.999999) + bigMask)); float opacity = lerp(1.0, min(bigOpacity, midOpacity), baseMask); float meshEmitInt = (bigMask - smallMask) * meshMask;//只在半透明的区域有发光效果 meshEmitInt = meshEmitInt * meshEmitInt * 2.0;//进行固定值的 power,让发光区域缩小 emission += _EffCol * meshEmitInt * baseMask; float3 FinalColor = dirlighting + envLighting + emission; return float4(FinalColor * opacity, opacity); } 要点 # EffMap01 R - WireframeMap 记录模型线框 G - RandomGrayScale 记录基于面的随机灰度图 B - DisappearanceGrayscale 记录基于面的统一深度图 EffMap02 3DPerlinNoise DisappearanceGrayscale\nRandomGrayScale\n贴图制作与合并\nmask 顶点色,让动画只作用于人物 baseMask = abs(frac(vertex.y * _EffParams.x - _Time.x * _EffParams.y) -0.5) * 2.0; frac(vertex.y) 只取小数,视觉表现为贴图 Gradient Linear 1 EffectParams.x 控制 Gradient Linear 1 Tiling EffectParams.y 控制动画速度和方向 abs(frac() -0.5) * 2.0 abs 取绝对值,最终结果将 Gradient Linear 1 转变成 Gradient Linear 3 baseMask = min() 增加取值为 1 的范围 baseMask += (noise - 0.5) * _EffParams.z; 使 baseMask 取值非 1 的区域产生变化,_EffParams.z控制变化强度 smoothstep 对指定区域进行波形调整 vertex.xz += 对透明部分进行动画,EffParams.w控制动画强度 floor 小于 1 的取 0, 大于 1 的取 1 saturate 限定值域为 (0, 1) meshEmitInt * meshEmitInt 等价于 Power = value^2 faceRandomMask = max(0.001, _EffectMap01_var.y) 防止出现负值,负值会导致显示错误 ","date":"2025-05-27","externalUrl":null,"permalink":"/zh-cn/notes/courses/zhuangdongcourse/vfxshader/","section":"笔记","summary":"","title":"庄懂的技术美术入门课 - 特效着色器","type":"notes"},{"content":" 07-点积与对偶性 # 点积的几何意义 # 两个向量 $\\vec{V}$ 和 $\\vec{W}$ 的点积,等于 $\\vec{W}$ 在 $\\vec{V}$ 方向上的投影长度乘以 $\\vec{V}$ 的长度.\n公式 # $$ (x_1, y_1) \\cdot (x_2, y_2) = x_1x_2 + y_1y_2 $$\n点积结果的符号: $\\vec{W}$ 的投影方向与 $\\vec{V}$ 相同,点积为正. $\\vec{W}$ 的投影方向与 $\\vec{V}$ 相反,点积为负. $\\vec{W}$ 与 $\\vec{V}$ 垂直,点积为零. 点积满足交换律:$\\vec{V} \\cdot \\vec{W} = \\vec{W} \\cdot \\vec{V}$. 假设 W 和 V 是长度相同的两个向量,它们在一条线上是对称的,此时 V 变成 2 倍长,W 投影在 V 的长度不变,V 投影在 W 上变成 2 倍 长,此时:\n$2(\\vec{V}) \\cdot \\vec{W} = 2(\\vec{V} \\cdot \\vec{W})$\n对偶性 # 一个二维向量经过 $1 \\times 2$ 矩阵变换的结果,与两个二维向量点积的结果相同.一个向量投影到另一个向量上,这个过程可以视作一种线性变换\n例:$[1, -2] \\begin{bmatrix}4 \\ 3\\end{bmatrix} = \\begin{bmatrix}1 \\ -2\\end{bmatrix} \\cdot \\begin{bmatrix}4 \\ 3\\end{bmatrix}$\n假设存在单位向量 $\\vec{U}$, 基向量 $i, j$ 在这个向量上的投影为 $U_x, U_y$, 则投影矩阵为 $[U_x, U_y]$. 任意向量通过 $[U_x, U_y]$ 变换到该直线,或与 $\\vec{U}$ 点积,计算结果相同.$\\vec{U}$ 与单位向量 $i$ 点积,等于 $\\vec{U}$ 在 $i$ 方向上的投影长度.若 $\\vec{U}$放大为原来的 3 倍,如 $[3U_x, 3U_y]$, 结果等于投影值乘以 3. 这种现象称为\u0026quot;对偶性\u0026quot;, 即矩阵向量乘积与点积之间的自然对应关系.\n08-叉积 # 第一部分:叉积的标准介绍 # 给定向量 $\\vec{V}$ 和 $\\vec{W}$, 将它们分别平移到对方终点,形成一个平行四边形的平面.叉积结果是垂直于这个平面的向量,长度等于平面面积.叉积产生的新向量朝向由右手定则确定.\n叉积的符号: # $\\vec{V}$ 在 $\\vec{W}$ 右侧,结果为正. $\\vec{V}$ 在 $\\vec{W}$ 左侧,结果为负. 公式 # 二维\n$$ \\det\\left(\\begin{bmatrix}X_1 \u0026amp; Y_1 \\ X_2 \u0026amp; Y_2\\end{bmatrix}\\right) = X_1Y_2 - X_2Y_1 $$\n三维\n$$ (V_1, V_2, V_3) \\times (W_1, W_2, W_3) = (V_2W_3 - V_3W_2, V_3W_1 - V_1W_3, V_1W_2 - V_2W_1 $$\n特点 # 两向量越接近垂直,面积越大. 其中一个向量放大,面积也按比例放大. 结果为负,表示坐标系取向发生翻转. 第二部分:以线性变换的视角看叉积 # 定义一个三维空间到一维的线性变换: 存在基向量$\\vec{V}\\vec{W}$, 任意向量$\\vec{U}$\n$$ \\vec{U} = \\begin{bmatrix}x \\ y \\ z\\end{bmatrix}, f((x, y, z)) = \\det\\left(\\begin{bmatrix}x \u0026amp; y \u0026amp; z \\ V_1 \u0026amp; V_2 \u0026amp; V_3 \\ W_1 \u0026amp; W_2 \u0026amp; W_3\\end{bmatrix}\\right) $$\n存在一个向量 $\\vec{P}$, 使得: $$\\begin{bmatrix}P_1 \\ P_2 \\ P_3\\end{bmatrix} \\cdot \\begin{bmatrix}x \\ y \\ z\\end{bmatrix} = \\det\\left(\\begin{bmatrix}x \u0026amp; y \u0026amp; z \\ V_1 \u0026amp; V_2 \u0026amp; V_3 \\ W_1 \u0026amp; W_2 \u0026amp; W_3\\end{bmatrix}\\right)$$\n垂直于基向量$\\vec{V}\\vec{W}$的轴为$K$\n三维空间中,平行六面体的体积,由 $\\vec{U}$ 在 $K$ 上的投影长度和$\\vec{V}\\vec{W}$构成的平面面积决定.\n$\\vec{P} \\cdot \\vec{U} = |\\vec{P}| \\times \\vec{U}_{\\text{\\scriptsize 投影于 P}}$\n$|\\vec{P}| \\times \\vec{U}{\\text{\\scriptsize 投影于 P}}$ = $\\vec{V}\\vec{W}$ 构成平面面积 × $\\vec{U}{\\text{\\scriptsize 投影于 K}}$.\n由此可得,$\\vec{P}$ 垂直于 $\\vec{V}\\vec{W}$ 构成的平面,长度等于该平面面积,因此等式成立.\n","date":"2025-05-25","externalUrl":null,"permalink":"/zh-cn/notes/foundation/linearalgebra/essenceoflinearalgebra_part3/","section":"笔记","summary":"","title":"线性代数的本质 - 03","type":"notes"},{"content":" 09-基变换 # 我们之前讨论的各种情况,都是在标准基向量 $\\hat{i} = \\begin{bmatrix} 1 \\ 0 \\end{bmatrix}$ 和 $\\hat{j} = \\begin{bmatrix} 0 \\ 1 \\end{bmatrix}$ 定义的坐标系中进行的.\n在不同的坐标系中,描述同一个向量的坐标是不同的,这是因为我们选用的基向量发生了改变.\n示例 # 假设有另一组基向量 $\\hat{i}\u0026rsquo; = \\begin{bmatrix} 2 \\ 1 \\end{bmatrix}$ 和 $\\hat{j}\u0026rsquo; = \\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$.\n在该坐标系中的向量 $\\begin{bmatrix} 5/3 \\ 1/3 \\end{bmatrix}$, 在我们的标准坐标系中被表示为 $\\begin{bmatrix} 3 \\ 2 \\end{bmatrix}$.\n坐标系变换 # 我们可以将新的基向量构成一个矩阵 $A = \\begin{bmatrix} 2 \u0026amp; -1 \\ 1 \u0026amp; 1 \\end{bmatrix}$. 用这个矩阵乘一个在其他坐标系下的向量,就能得到它在标准坐标系下的表示. $$\\begin{bmatrix} 2 \u0026amp; -1 \\ 1 \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} 5/3 \\ 1/3 \\end{bmatrix} = \\begin{bmatrix} 3 \\ 2 \\end{bmatrix}$$\n坐标系逆变换 # 只需取上述矩阵 $A$ 的逆矩阵 $A^{-1}$. 用 $A^{-1}$ 乘一个标准坐标系下的向量,就能得到它在其他坐标系下的表示. 案例 # 如何在两个不同的坐标系中实现相同的变换?(例如逆时针旋转 90°)\n假设 $M$ 是标准坐标系下的变换矩阵 (旋转 90°: $M = \\begin{bmatrix} 0 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix}$). 假设 $A$ 是从其他坐标系到标准坐标系的变换矩阵. 在其他坐标系中实现同样变换的矩阵为 $A^{-1}MA$. 这个操作的直观理解是:\n$A$: 将向量从其他坐标系变换到标准坐标系. $M$: 在标准坐标系中进行旋转. $A^{-1}$: 将结果变换回原来的坐标系. 对于基向量为 $\\begin{bmatrix} 2 \\ 1 \\end{bmatrix}$ 和 $\\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$ 的坐标系,其旋转 90°的变换矩阵为: $A^{-1}MA = \\begin{bmatrix} 2 \u0026amp; -1 \\ 1 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 1/3 \u0026amp; 1/3 \\ -1/3 \u0026amp; 2/3 \\end{bmatrix} = \\begin{bmatrix} 1/3 \u0026amp; -5/3 \\ 2/3 \u0026amp; -1/3 \\end{bmatrix}$\n10-特征向量与特征值 # 特征向量 (Eigenvector) # 在经历矩阵所描述的线性变换时,方向保持不变 (仅在其张成的空间内伸缩) 的非零向量.\n特征值 (Eigenvalue) # 特征向量在变换过程中被###拉伸或压缩的比例因子.\n从几何上看,如果一个三维空间的旋转可以被看作是围绕一个轴进行的,那么这个轴的方向向量就是一个特征向量,其对应的特征值为 1 (因为它在旋转中没有被拉伸). 这种理解方式远比一个 3x3 矩阵要直观.\n计算方法 # 公式:$A\\vec{v} = \\lambda\\vec{v}$\n$A$: 变换矩阵 $\\vec{v}$: 特征向量 $\\lambda$: 特征值 为了求解,我们将公式变形: $A\\vec{v} - \\lambda\\vec{v} = 0$ $A\\vec{v} - \\lambda I\\vec{v} = 0$ $(A - \\lambda I)\\vec{v} = 0$\n这个结果说明,特征向量 $\\vec{v}$ 经过 $(A - \\lambda I)$ 变换后,会被压缩成零向量. 这意味着变换 $(A - \\lambda I)$ 是一个降维的变换,所以它的行列式必定为零. $\\det(A - \\lambda I) = 0$ 示例 # 对于矩阵 $A = \\begin{bmatrix} 3 \u0026amp; 1 \\ 0 \u0026amp; 2 \\end{bmatrix}$: $\\det(A - \\lambda I) = \\det \\left( \\begin{bmatrix} 3 \u0026amp; 1 \\ 0 \u0026amp; 2 \\end{bmatrix} - \\lambda \\begin{bmatrix} 1 \u0026amp; 0 \\ 0 \u0026amp; 1 \\end{bmatrix} \\right) = \\det \\begin{bmatrix} 3-\\lambda \u0026amp; 1 \\ 0 \u0026amp; 2-\\lambda \\end{bmatrix} = (3-\\lambda)(2-\\lambda) = 0$ 解得特征值 $\\lambda = 2$ 或 $\\lambda = 3$.\n当 $\\lambda = 2$ 时,我们求解 $(A - 2I)\\vec{v}$ = $\\begin{bmatrix} 1 \u0026amp; 1 \\ 0 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} = \\begin{bmatrix} 0 \\ 0 \\end{bmatrix}$ 所有解都在向量 $\\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$ 所张成的空间上.\n当 $\\lambda = 3$ 时,矩阵 $\\begin{bmatrix} 3 \u0026amp; 1 \\ 0 \u0026amp; 2 \\end{bmatrix}$ 会将对应的特征向量拉伸为原来的 3 倍.\n特性与应用 # 没有特征向量的变换 # 二维空间中逆时针旋转 90°的变换就没有实数域上的特征向量.\n多个特征向量的变换 # 缩放矩阵\n对角矩阵 # 如果一个变换的基向量恰好都是特征向量,那么描述该变换的矩阵是一个###对角矩阵###, 矩阵的对角元就是这些基向量对应的特征值.\n简化高次幂计算 # 对角矩阵的幂次计算非常简单,只需计算其对角元 (特征值) 的相应幂次即可.当我们需要多次计算一个非对角矩阵 $M$ 时,如果它有足够的特征向量,我们可以:\n将特征向量作为新的基向量,构成基变换矩阵 $A$. 通过 $A^{-1}MA$ 将 $M$ 转换为对角矩阵 $D$. 计算 $D^n$. 通过 $A D^n A^{-1}$ 将结果转换回原坐标系,即 $M^n = A D^n A^{-1}$. 11-抽象向量空间 # 向量和函数有共同点.\n函数作为向量 # 线性性质 # 许多对函数的操作 (如求导) 都是线性的,即满足:\n可加性:$L(f + g) = L(f) + L(g)$\n成比例:$L(cf) = cL(f)$\n多项式的向量表示:我们可以将多项式看作一个维度无限的向量.\n以一组基函数 $b_0(x)=1, b_1(x)=x, b_2(x)=x^2, \\dots$ 为例. $1x^2 + 3x + 5 \\cdot 1$ 可以视为向量 $\\begin{bmatrix} 5, 3, 1, 0, \\dots \\end{bmatrix}^T$. $4x^7 - 5x^2$ 可以视为向量 $\\begin{bmatrix} 0, 0, -5, 0, 0, 0, 0, 4, \\dots \\end{bmatrix}^T$. 求导的矩阵表示:求导这个变换也可以用矩阵来描述.\n$\\frac{d}{dx}(a_n x^n + \\dots + a_1 x + a_0) = n a_n x^{n-1} + \\dots + a_1$ 这个变换作用在多项式对应的向量上,就像一个矩阵作用于一个向量. 八条公理 # 之所以会这样,是因为向量计算和函数计算都符合这八条公理:\n向量加法结合律:$U + (V + W) = (U + V) + W$ 向量加法交换律:$V + W = W + V$ 加法单位元存在:存在一个零向量 $0$, 使得 $0 + V = V$ 加法逆元存在:对任意向量 $V$, 存在 $-V$, 使得 $V + (-V) = 0$ 标量乘法与域乘法相容:$a(bV) = (ab)V$ 标量乘法单位元存在:$1V = V$ 标量乘法对向量加法分配律:$a(V + W) = aV + aW$ 标量乘法对域加法分配律:$(a + b)V = aV + bV$ ","date":"2025-05-25","externalUrl":null,"permalink":"/zh-cn/notes/foundation/linearalgebra/essenceoflinearalgebra_part4/","section":"笔记","summary":"","title":"线性代数的本质 - 04","type":"notes"},{"content":" 03-矩阵与线性变换 # 线性变换 # 你可以把它理解成一种函数,即意味着有输出和输入,输入一个向量,输出一个向量,中间的计算,即变换过程体现了向量的运动规律.\n特征 # 直线在变换后依旧是直线 (包裹向量构成的对角线) 原点位置不变 网格线保持平行且等距分布 线性变换\n非线性变换\n案例 # 我们可以通过数值来描述线性变换\n原始基向量: \\( \\hat{i} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} , \\hat{j} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\)\n考虑坐标为 (-1, 2) 的向量 \\(\\vec{V}\\) 时:\n$$ \\vec{v} = -1 \\hat{i} + 2 \\hat{j} = -1 \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} + 2 \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix} $$\n如果运用一些变换,基向量会和向量 \\(\\vec{v}\\)一起运动\n变换后的基向量:\\(\\hat{i}\u0026rsquo; = \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix}, \\hat{j}\u0026rsquo; = \\begin{bmatrix} 3 \\\\ 0 \\end{bmatrix}\\)\n$$ \\vec{v}\u0026rsquo; = -1 \\hat{i}\u0026rsquo; + 2 \\hat{j}\u0026rsquo; = -1 \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} + 2 \\begin{bmatrix} 3 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} -1 \\cdot 1 + 2 \\cdot 3 \\\\ -1 \\cdot (-2) + 2 \\cdot 0 \\end{bmatrix} = \\begin{bmatrix} 5 \\\\ 2 \\end{bmatrix} $$\n由此得出,我们可以通过\\(\\hat{i}\u0026rsquo;\\)和\\(\\hat{j}\u0026rsquo;\\)来推断\\(\\vec{v}\\)变换后的落脚点\n一个二维线性变换仅由四个数字完全确定,也就是变换后的\\(\\hat{i}\u0026rsquo;\\)和\\(\\hat{j}\u0026rsquo;\\)的坐标,通常我们将这些坐标包装在一个 2X2 的格子中,称它为 2X2 矩阵,只需输入一个向量\\(\\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}\\), 我们就可以通过\\(\\begin{bmatrix} 1 \u0026amp; 3 \\\\ -2 \u0026amp; 0 \\end{bmatrix}\\)得到变换后的向量\\(\\begin{bmatrix} 5 \\\\ 2 \\end{bmatrix}\\)\n公式 # $$ \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = x \\begin{bmatrix} a \\\\ c \\end{bmatrix} + y \\begin{bmatrix} b \\\\ d \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix} $$\n常用矩阵 # 逆时针旋转 90° \\(\\begin{bmatrix} 0 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\)\n剪切 \\(\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \\end{bmatrix}\\)\n列线性相关 \\(\\begin{bmatrix} 2 \u0026amp; -2 \\\\ 1 \u0026amp; -1 \\end{bmatrix}\\) (意味着其中一个向量是另一个向量的倍数)\n04-矩阵乘法与线性变换复合 # 复合变换 # 核心定义:是多个线性变换的有序组合,通过追踪基向量的最终位置记录变换过程\n计算示例:先旋转 (矩阵 R = \\(\\begin{bmatrix} 0 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\)) 再剪切 (矩阵 S = \\(\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \\end{bmatrix}\\)), 复合矩阵 S·R = \\(\\begin{bmatrix} 1 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\)\n顺序规则 : 矩阵乘法从右向左读 (如 f(g(x))), 源于函数复合的顺序逻辑\n矩阵乘法计算 # 设 \\(M_1\\) = \\(\\begin{bmatrix} 1 \u0026amp; -2 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\), \\(M_2\\) = \\(\\begin{bmatrix} 0 \u0026amp; 2 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\)\n基向量\\(\\hat{i}\u0026rsquo;\\)的路径:\\(M_1\\) 的 \\(\\hat{i}\u0026rsquo;\\) 经 \\(M_2\\)变换:\n1 X \\(\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\) + 1 X \\(\\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 \u0026amp; 2 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 + 2 \\\\ 1 + 0 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}\\)\n基向量\\(\\hat{j}\u0026rsquo;\\)的路径:\\(M_1\\) 的 \\(\\hat{j}\u0026rsquo;\\) 经 \\(M_2\\)变换:\n(-2) X \\(\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\) + 0 X \\(\\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 \u0026amp; 0 \\\\ -2 \u0026amp; 0 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 + 0 \\\\ -2 + 0 \\end{bmatrix}\\) = \\(\\begin{bmatrix} 0 \\\\ -2 \\end{bmatrix}\\)\n复合矩阵:\\(\\begin{bmatrix} 2 \u0026amp; 0 \\\\ 1 \u0026amp; -2 \\end{bmatrix}\\)\n通用公式 # \\(M_2\\) = \\(\\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix}, M_1 = \\begin{bmatrix} e \u0026amp; f \\\\ g \u0026amp; h \\end{bmatrix}\\) \\(M_2M_1\\) = \\(\\begin{bmatrix} ae + bg \u0026amp; af + bh \\\\ ce + dg \u0026amp; cf + dh \\end{bmatrix}\\)\n运算性质 # 不满足交换律:\\(M_1M_2\\) ≠ \\(M_2M_1\\) 满足结合律:(AB)C = A(BC) 三维空间中的扩展 # 基向量增加:引用 Z 轴方向的基向量 \\(\\hat{k}\u0026rsquo;\\) 坐标 \\(\\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}\\)\n线性变换由\\(\\hat{i}\u0026rsquo;, \\hat{j}\u0026rsquo;, \\hat{k}\u0026rsquo;\\)变换后的位置决定\n向量变换计算规则与二维相同\n\\(M_1 \\vec{v}\\) = x \\(\\begin{bmatrix} a \\\\ b \\\\ c \\end{bmatrix}\\) + y \\(\\begin{bmatrix} d \\\\ e \\\\ f \\end{bmatrix}\\) + z\\(\\begin{bmatrix} g \\\\ h \\\\ i \\end{bmatrix}\\)\n05-行列式 # 行列式的几何本质 # 行列式描述线性变换对空间体积或面积的缩放比例\n正负号代表空间是否反转\n右手定理 # 我们通常使用右手定理,即指向前方的无名指代表 \\(\\hat{i}\u0026rsquo;\\) 指向侧边的中指代表 \\(\\hat{j}\u0026rsquo;\\) 指向上方的拇指代表 \\(\\hat{k}\u0026rsquo;\\) 如果用左手表示这个空间,说明空间取向翻转,行列式为负\n特殊情况 # 行列式 = 0: 空间被压缩至低维\n行列式 = 1: 保持体积不变\n公式 # $$ \\det \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d \\end{bmatrix} = ad - bc $$\nad: 表示基向量缩放后形成的矩形面积\nbc: 表示平行四边形沿对角线方向拉伸或压缩了多少\n案例 # $$ \\det(M_1M_2) = \\det(M_1) \\cdot \\det(M_2) $$\n假设对单位正方形进行变换,M1 为放大 2 倍,M2 为放大 4 倍,\n\\(\\det(M_1M_2)\\) 可以理解为先放大 4 倍再放大 2 倍,即 1 x (4 x 2),\n\\(\\det(M_1) \\cdot \\det(M_2)\\) 可以理解为 1 x 2 x 4,\n两者相等\n06-逆矩阵,列空间与零空间 # 线性方程组 # 线性方程组是指包含若干未知量和相关方程的集合,每个方程中的未知量仅有常系数,并且这些未知量之间只进行加法运算.这类方程组可以统一表示为向量方程:\n例子:\n$$ \\begin{cases} 2x + 5y + 3z = -3 \\\\ 4x + 0y + 8z = 0 \\\\ 1x + 3y + 0z = 2 \\end{cases} $$\n可写成矩阵形式:\n$$ \\begin{bmatrix} 2 \u0026amp; 5 \u0026amp; 3 \\\\ 4 \u0026amp; 0 \u0026amp; 8 \\\\ 1 \u0026amp; 3 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix}x \\\\ y \\\\ z\\end{bmatrix} = \\begin{bmatrix}-3 \\\\ 0 \\\\ 2\\end{bmatrix} $$\n其中,左侧矩阵为 \\(A\\), 未知向量为 \\(X\\), 右侧为 \\(V\\), 即 \\(AX = V\\).\n逆矩阵的概念 # 逆矩阵 \\(A^{-1}\\) 可以理解为\u0026quot;还原\u0026quot;变换的工具. 如果 \\(AX = V\\) 那么 \\(X = A^{-1}V\\) 即通过逆矩阵可以解出原始的未知数. 只有当 \\(A\\) 是方阵且 \\(\\det(A) \\neq 0\\) 时,逆矩阵才存在. 如果矩阵把空间\u0026quot;压缩\u0026quot;了 (降维), 逆矩阵就不存在. 特殊情况:如果降维后,某个向量正好落在目标空间上,这个向量可以被逆变换还原. 术语解释 # 秩 (Rank): 空间变换后的维度.变换后是一维,秩为 1; 二维,秩为 2; 以此类推. 列空间 (Column Space): 所有可能的输出向量集合,即 \\(Av\\) 构成的空间,由矩阵 \\(A\\) 的列向量张成. 张成空间 (Span) 与列空间的区别: span 指任意向量集合的线性组合的所有可能结果,column space 是矩阵与任意向量相乘后所有可能结果的集合. span 可应用于任意向量集合,column space 与线性方程组 \\(Ax = v\\) 的解存在性直接相关. 满秩:秩与列数相等. 零向量:坐标为 (0, 0) 的向量.满秩时,零向量是原点; 非满秩时,有多个向量变成零向量. 零空间/核 (Null Space/Kernel): 变换后落在原点的所有向量的集合. 6-补充说明 非方阵 # 非方阵是指行数和列数不相等 (\\(m \\neq n\\)) 的矩阵. 例如: \\(\\begin{bmatrix}2 \u0026amp; -1 \u0026amp; 2 \\\\ 0 \u0026amp; 1 \u0026amp; 1\\end{bmatrix}\\): 2 行 3 列,表示从三维空间映射到二维空间 (如三维空间中的点被投影到一个平面上). \\(\\begin{bmatrix}3 \u0026amp; 1 \\\\ 1 \u0026amp; 5 \\\\ 4 \u0026amp; 9\\end{bmatrix}\\): 3 行 2 列,表示从二维空间映射到三维空间 (如二维平面上的点被拉伸到三维空间). \\(\\begin{bmatrix} 1 \\ 2 \\end{bmatrix}\\): 1 行 2 列,表示从二维空间映射到一维空间 (如二维空间中的点被压缩到一条线上). ","date":"2025-05-24","externalUrl":null,"permalink":"/zh-cn/notes/foundation/linearalgebra/essenceoflinearalgebra_part2/","section":"笔记","summary":"","title":"线性代数的本质 - 02","type":"notes"},{"content":"","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"}]
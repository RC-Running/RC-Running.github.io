


[{"content":"\r01-向量究竟是什么？ #\r定义：向量是具有大小和方向的量\n表示方式：\n通常用箭头或带方向的线段表示 关键属性是长度 (模长) 和方向 示例：向量 (-2, 3) 表示从原点 (0,0) 指向点 (-2,3) 的箭头 向量模长计算公式\n$$ |\\vec{v}| = \\sqrt{x^2 + y^2} $$\n特征：\n存在多维向量 (二维/三维在游戏领域最常用) 本质是有序数字列表，可代表多种事物 向量相加\n可以视作从原点沿两个向量方向移动，比如向量 V+向量 W，意味着我们先往向量 V 方向移动，再往向量 W 方向移动，移动距离为它们的模长\n视频 vectoradd.py\n向量相加公式\n$$ \\vec{a} + \\vec{b} = \\begin{bmatrix} x_1 \\ y_1 \\end{bmatrix} + \\begin{bmatrix} x_2 \\ y_2 \\end{bmatrix} = \\begin{bmatrix} x_1 + x_2 \\ y_1 + y_2 \\end{bmatrix} $$\n向量和标量相乘\n也可以称作向量的缩放\n视频vectorscale.py\n数乘公式\n$$ \\vec{v} = k \\cdot \\vec{v} = (k v_x, k v_y, k v_z) $$\n02-线性组合，张成的空间与基 #\r在二维坐标系 (xy 平面) 中，有两个特殊的向量\n一个指向正右方，长度为 1, 称为 \u0026ldquo;i 帽\u0026rdquo; 另一个指向正上方，长度为 1, 称为 \u0026ldquo;j 帽\u0026rdquo; 这两个向量共同构成该坐标系的 \u0026ldquo;基向量\u0026rdquo;, 它们是坐标系的基础框架。\n例如，向量 (3, -2) 可以理解为\n将基向量 i 帽拉伸 3 倍 将基向量 j 帽拉伸 2 倍 最终向量 (3, -2) 就是这两个缩放后的向量的和 (3i + (-2j)) 视频ijscale.py\n这里，坐标值 3 和 -2 被视为标量，而基向量则是被这些标量缩放的对象\n两个向量标量乘法之和被称为线性组合\n$$ \\vec{U} = a\\vec{V} + b\\vec{W} $$\na,b 为标量\n张成空间是什么\n想象你有几个箭头，张成空间就是只用这些箭头，通过两种最基础的操作 - 向量加法和数乘 -你能到达的所有可能位置构成的集合\n二维\n图片span2d.py\n一般情况\n图片spanline.py\n共线 即构成空间的向量在同一条线上\n三维\n图片3dspan.py\n平面 即构成空间的向量在同一平面上\n图片3dspanplate.py\n存在一个向量，和其他向量不在同一个平面上，当你伸缩这个向量时，它会把平面沿它的方向移动，从而达到三维空间的任何一点\n线性相关\n如果移除一个向量，发现张成空间没有变小，那么说明这个向量是多余的。它本身是由其他向量通过数乘和相加得到的，这类向量被称为线性相关\n线性无关\n如果移除一个向量，发现张成空间变小，说明这个箭头不是多余的，这样的向量被称为线性无关\n基\n向量空间的一个基，就是一组数量最少的，线性无关的向量\n能张成整个空间 都是线性无关的 ","date":"10 June 2025","externalUrl":null,"permalink":"/notes/foundation/linearalgebra/essenceoflinearalgebra_part1/","section":"Notes","summary":"","title":"EssenceOfLinearAlgebra_Part1","type":"notes"},{"content":"","date":"10 June 2025","externalUrl":null,"permalink":"/tags/space/","section":"Tags","summary":"","title":"Space","type":"tags"},{"content":"","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"\r了解如何使用简单而强大的 Blowfish。\r","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/notes/foundation/","section":"笔记","summary":"","title":"线性代数的本质","type":"notes"},{"content":"\r了解如何使用简单而强大的 Blowfish。\r","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/notes/courses/","section":"笔记","summary":"","title":"庄懂的技术美术入门课","type":"notes"},{"content":"\r了解如何使用简单而强大的 Blowfish。\r","date":"2025-06-09","externalUrl":null,"permalink":"/zh-cn/portfolio/","section":"作品集","summary":"","title":"作品集","type":"portfolio"},{"content":"\r了解如何使用简单而强大的 Blowfish。\r","date":"2025-06-07","externalUrl":null,"permalink":"/zh-cn/notes/","section":"笔记","summary":"","title":"笔记","type":"notes"},{"content":"\r了解如何使用简单而强大的 Blowfish。\r","date":"2025-06-07","externalUrl":null,"permalink":"/zh-cn/notes/courses/zhuangdongstaintrocourse/","section":"笔记","summary":"","title":"文章","type":"notes"},{"content":"\r了解如何使用简单而强大的 Blowfish。\r","date":"2025-06-07","externalUrl":null,"permalink":"/zh-cn/notes/foundation/linearalgebra/","section":"笔记","summary":"","title":"文章","type":"notes"},{"content":"\r22. Unity内置LightingMap烘焙系统 #\r22.1 烘焙前的设置 #\r###设置天空盒###\n路径：Windows → Rendering → Lighting Settings → Skybox Material ###场景物体设置为静态（Static）###\n启用 Contribute GI 和 Reflection Probe Static 各静态选项说明： Contribute GI：响应全局光照 Occluder/Occludee Static：响应遮挡剔除（OccCulling） Batching Static：合批优化 Navigation Static/Off Mesh Link Generation：导航相关 Reflection Probe Static：决定物体是否出现在反射探头记录中 ###主平行光、自发光材质、反射探头设置###\n自发光材质 Global Illumination 设为 Baked，Color 设为 HDR ###LightingMode 设置###\n路径：Windows → Rendering → Lighting Settings → MixedLighting → LightingMode LightingMode 选项： Baked Indirect Subtractive ShadowMask Directional Light Mode： RealTime Mixed Baked ShadowMask Mode 需在 ProjectSetting → Quality → Shadow → Shadowmask Mode 开启\n###注###: ShadoeMask Mode 额外生成一张Shadowmask贴图 ###组合列表###:\nBake Indirect Runtime\nLM = GI = EmitLighting + SkyLighting\n投影: 实时投影\nMixed\nLM = GI = EmitLighting + SkyLighting + LightsGI\n投影: 实时投影\nBaked\nLM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting\n投影: 静态物: 投影写入LM 动态物: 无\nSubtractive Runtime\nLM = GI = EmitLighting + SkyLighting\n投影: 实时投影, RealTime Shadow Color设置失效\nMixed\nLM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting\n投影: 静态物: 投影写入LM 动态物: 实时; RealTime Shadow Color设置有效\nBaked\nLM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting\n投影: 静态物: 投影写入LM 动态物: 无; RealTime Shadow Color设置失效\nShadowMask Runtime\nLM-light = GI = EmitLighting + SkyLighting\nLM-shadowmask = null\n投影: 实时投影\nMixed\nLM-light = GI = EmitLighting + SkyLighting + LightsGI\nLM-shadowmask = LightsShadow\n投影: 静态物: 投影写入LM 动态物: 实时投影\nBaked\nLM = GI + DL = (EmitLighting + SkyLighting + LightsGI) + LightsLighting\nLM-shadowmask = null\n投影: 静态物: 投影写入LM 动态物: 无\n###Lighting说明###:\nEmitLighting 代表发光材质造成的光照 SkyLighting 代表天空球造成的光照 LightsGI 代表主光造成的反弹光 LightsLighting 代表主光造成的光照 LM = Lightmap, DL = DirectLighting ###注###: Subtractive和ShadowMask对动态物体的实时投影的处理不同\nShadowMask对动静态物的投影混合更自然\n###Lightmapping Setting###\nLightmapper: Progressive CPU Lightmap Resolution: 40 Directional Mode: Non-Directional（一般不推荐, 效果不明显, 能耗翻倍） ###常见方案：###\n全实时光照：不需要Lightmap 全实时直接光照 + Baked Indirect 静态物体烘焙，动态物体实时（Subtractive/ShadowMask） 辅助光只用于烘焙（Baked/Mixed）Mixed决定是否影响动态物体 特效 RealTime 22.2 合批策略与烘焙过程分析 #\r###定义###: 把渲染过程相同的几个批次的渲染合并起来, 节省资源, 增加速度\n一般情况下, 共用Material, 参数相同才能合批\n###常见策略###:\nUnity static设置 Unity SRPBatching (同Shader即可合批) GPU Instancing 手动合批 (DDC软件内合并模型) ###注###: Windows → Analisis → FrameDebugger\nFrameDebugger 可查看合批与渲染过程\n23. 外部LightingMap烘焙与自定义Shader #\r23.1 外部烘焙流程 #\r使用3dsMax/MAYA烘焙LightingMap，需为模型创建UV2 贴图： AO Map 代替SkyLighting EmitLighting LightsShadow LightGI + LightsLighting Alpha 用SD的Blur HQ节点消除噪点，合并贴图节省资源 ###光照构成###\n光照构成\r-漫反射(Lambert) -\r-简单光源-主平行光| | -遮挡(LM) -\r| -镜面反射(Phong) - |\r光照-| |-结果\r| -天光 -漫反射(Cubemap) -遮挡(LM)- |\r-复杂环境-|-自发光 -漫反射-(1Col) -遮挡(LM)- | |-其他环境光 -漫反射 -忽略 |\r| -遮挡(SurfaceOcc)- |\r-镜面反射(Cubemap)| |- -衰减(Fresnel) -\r23.2 Shader核心结构 #\rShader \u0026#34;Zhuangdong/AP1/L15/L15_LightingMap\u0026#34; { Properties{ // ... 贴图与参数声明 ... } SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; // ... 以orge案例为模板, 顶点着色器移除TRANSFER_VERTEX_TO_FRAGMENT(o) ... VertexOutput vert(VertexInput v) { ... //案例需要2个uv, 这里将2个uv合并到一个float4, 节省TEXCOORD o.uvs = float4(v.uv0, v.uv1); ... } float3 DecodeNormal (float2 maskXY) { //贴图只有RG两个通道，我们要补上B通道 float2 nDirTSxy = maskXY * 2.0 - 1.0; //贴图值域在(0,1),法线是向量，向量值域在(-1,1) float nDirTSz = sqrt(1.0 - (nDirTSxy.x * nDirTSxy.x + nDirTSxy.y * nDirTSxy.y)); //sqrt取平方根,x平方+y平方+z平方=1 return float3(nDirTSxy, nDirTSz); } float4 frag(VertexOutput i) : COLOR { // ... 采样、向量、点乘 ... //提取表面信息 float occlusion = var_MaskTex.r; float matMask = var_MaskTex.g;//金属贴图 float3 diffCol = var_MainTex.rgb * lerp(1.0, _MetalDarken, pow(matMask, 5.0)); //这里给金属叠加_MetalDarken，降低金属部分的diff float specPow = max(1.0, lerp(_SpecParams.x, _SpecParams.z, matMask)); float specInt = max(0.0, lerp(_SpecParams.y, _SpecParams.w, matMask)); float reflectMip = clamp(lerp(_EnvReflectParams.x, _EnvReflectParams.z, matMask), 0.0, 7.0); //clamp即clamp(value,min,max)会将value限制在(min,max)中 float reflectInt = max(0.0, lerp(_EnvReflectParams.y, _EnvReflectParams.w, matMask)); float fresnel = lerp(pow(1.0 - max(0.0, ndotv), _FresnelPow), 1.0, matMask); //区分金属和非金属的Fresnel强度 //提取光照信息 float skyLightOcc = var_LightMap.r; float emitLightingInt = var_LightMap.g; float mainLightGIInt = pow(var_LightMap.b, _GIpow); float mainLightShadow = var_LightMap.a; //采样纹理Cube float3 var_SkyCube = texCUBElod(_SkyCube, float4(vrDirWS, 7.0)).rgb; float3 var_EnvCube = texCUBElod(_EnvCube, float4(vrDirWS, reflectMip)).rgb; //MainLight //Diff float3 halfShadowCol = lerp(_HalfShadowCol.rgb, _MainLightCol, mainLightShadow); //先给阴影和主光赋予颜色 float3 mainLightCol = lerp(_MainLightCol, halfShadowCol, _HalfShadowCol.a) * mainLightShadow; //再用投影mask去掉阴影颜色，留下的就是主光颜色和半影颜色，这里_HalfShadowCol.a控制半影强度 float3 mainLightDiff = diffCol * mainLightCol * max(0.0, nDotl); //DiffCol*Lambert*MainLight //Spec float3 mainLightSpec = mainLightCol * pow(max(0.0, vDotr), specPow) * specInt;//Phong //GI float3 mainLightGI = _GICol * occlusion * mainLightGIInt * _GIInt; //GI也就是主光的反弹光，这里叠加AO增加变化 //Mixed float3 mainLight = (mainLightDiff + mainLightSpec + mainLightGI * _MainLightGIOn) * _MainLightOn; //这里GI已经有环境AO的信息了，所以不用*LM //OtherLight float3 skyLightDiff = diffCol * var_SkyCube * _SkyCol * _SkyLightInt * skyLightOcc * occlusion; //这里是物体漫反射*天光漫反射*LM(LightingMap) float3 emitLightDiff = diffCol * _EmissionCol * emitLightingInt * occlusion; //同上，这部分不受环境AO影响，所以不用*_SkyLightOcc //OtherEnvSpec float3 envLightSpec = var_EnvCube * reflectInt * fresnel * occlusion; float3 OtherLight = skyLightDiff * _SkyLightOn + emitLightDiff * _EmitLightOn + envLightSpec * _EnvReflectOn; float3 finalRGB = mainLight + OtherLight; return float4(finalRGB, 1.0); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } ###关键参数说明###:\n_SpecParams x: 非金属高光次幂 y: 非金属高光强度 z: 金属高光次幂 w: 金属高光强度 _EnvReflectParams x: 非金属Cube采样Mip值 y: 非金属反射强度 z: 金属Cube采样Mip值 w: 金属反射强度 ###要点总结：###\n法线贴图只有RG，需手动补B通道 半影染色 金属/非金属参数分开控制高光、反射 根据光照构成合成光照 24-26. LightingController自定义烘焙器与多脚本协作 #\r由于此案例代码内容过多, 讲解以摘要为主, 如需源代码请自行到教程处下载\n功能与文件结构 #\r###LightingController###：负责整个烘焙流程的主脚本。 ###LightingControllerGUI###：自定义烘焙面板（UI），让操作更直观。 ###EmissionShaderGUI###：让材质球在Inspector界面可以设置自发光参与GI。 ###Building/EmitLight/Sky###：分别对应建筑、发光、天空球的Shader。 全局参数简明说明 #\r###MetalDarken###：金属部分的暗度（影响金属表面反光强度）。 ###MainLightCol###：主光颜色。 ###SpecParams###：高光参数（x/z为高光次幂，y/w为高光强度，分别对应金属/非金属）。 ###SkyLightInt###：天光强度。 ###ReflectParams###：反射参数（x/z为CubeMap Mip，y/w为反射强度）。 ###FresnelPow###：菲涅尔现象的强度。 ###EmissionCol###：自发光颜色。 烘焙流程 #\r###收集场景烘焙信息###：包括贴图数量、路径、纹理对象 ###创建缓存###：为主光、天光、自发光GI和最终合成的Lightmap分别准备缓存。 ###烘焙###：依次烘焙主光、天光、自发光GI，每步结果都存入缓存。 ###合成Lightmap###：把三步烘焙的结果合成一张最终Lightmap。 ###替换旧Lightmap###：用新合成的Lightmap覆盖场景原有的光照贴图。 ###重置场景光照环境###：修改场景设置。 ###更新全局参数###：同步参数到所有相关材质。 ###烘焙反射探头###：让反射效果也能正确显示。 ###核心代码示例：###\npublic void MultiBake() { var buffer = new LightmapsBuffer(); Bake(BakeMode.BakeMainLight); var info = new LightmapsInfo(LightmapSettings.lightmaps); buffer.WriteBuffer(info, LightmapsBuffer.BufferType.MainLight); Bake(BakeMode.BakeSkyLight); buffer.WriteBuffer(info, LightmapsBuffer.BufferType.SkyLight); Bake(BakeMode.BakeEmissionGI); buffer.WriteBuffer(info, LightmapsBuffer.BufferType.EmissionGI); buffer.CreateLightmaps(); buffer.OverrideLightmaps(info); buffer.Clear(); ArrangeBakeScene(BakeMode.Default); UpdateGlobalProperties(); BakeReflectProbe(); } LightingController #\r类与继承, 方法与生命周期 #\rpublic class LightingController : MonoBehaviour ###class###：可以理解为“蓝图”，比如Shader是蓝图，Material是根据蓝图做出来的“物品”。 ###继承（inheritance）###：比如“载具”是父类，“小轿车”是子类，子类自动拥有父类的基本功能。 MonoBehaviour：Unity所有能挂在物体上的脚本都要继承它，才能参与游戏生命周期。 [ExecuteInEditMode]: 一般情况下, 脚本只会在PlayMode下运行, 这个指令让脚本在预览窗口也会运行 private void OnEnable() {UpdateGlobalProperties();}; void 不同于之前案例的方法, void类函数不返回值, 它主要用于执行特定操作.\nOnEnable 意味着这个函数在游戏生命周期的OnEnable阶段开始运行\n###注###: UpdateGlobalProperties() 的方法写在OnEnable后面, 这在C#是允许的\nLightmapsInfo #\r要了解以下概念, 才能理解LightmapsInfo的作用\nLightmapData, 结构体 struct、构造函数、Dictionary（字典）和 foreach 循环\nLightmapData #\rLightmapData[]是Unity的数据类型, 它是当前场景所有光照贴图的集合 lightmapsData是自定义名称, 代表LightmapData[], 用于函数内部操作 LightmapsData[]里面包含多个实例, 每个实例代表每张Lightingmap, 每个实例包含: lightmapColor lightmapDir shadowMask occlusionMask 结构体和构造函数 #\r###结构体（struct）###：可以理解为一个“容器”，里面可以装不同类型的数据。 ###语法### public/private 名称(和class/struct同名) (类型, 参数名) ###构造函数###：用来初始化结构体（或类）的特殊函数，名字和结构体同名。 ###示例：###\npublic struct LightmapsInfo { public readonly Dictionary\u0026lt;string, Texture2D\u0026gt; lightmapsInfo; public LightmapsInfo(LightmapData[] lightmapsData) { // 这里会自动初始化所有内容 } } public class Person { public string Name; public int Age; // Constructor public Person(string name, int age) { Name = name; Age = age; } } 如果没有构造函数，你需要手动一项项赋值，非常繁琐。 有了构造函数，只需 new LightmapsInfo(参数)，所有内容自动安排好。 构造函数的多种用法 #\r构造函数可以有多个，参数不同或方法不同即可。 还可以在构造函数里做参数检查，防止出错。 ###示例：###\npublic LightmapsInfo(LightmapData[] lightmapsData){ if(lightmapsData == null) { // 做一些容错处理 } // 其他初始化内容 } Dictionary（字典） #\r###Dictionary### 是一种“键值对”容器，可以通过“名字”快速找到对应的内容。 例如：Dictionary\u0026lt;string, Texture2D\u0026gt;，可以用字符串名字查找对应的贴图路径和对象。 ###案例：###\nDictionary\u0026lt;string, Texture2D\u0026gt; myDict = new Dictionary\u0026lt;string, Texture2D\u0026gt;(); myDict[\u0026#34;MainLight\u0026#34;] = mainLightTex; Texture2D tex = myDict[\u0026#34;MainLight\u0026#34;]; foreach 循环 #\r###foreach### 用于遍历集合（如数组、List、Dictionary等) ###示例：###\n//data代表实例 foreach (var data in lightmapsData) { var texture = data.lightmapColor; path = AssetDatabase.GetAssetPath(texture); lightmapsInfo.Add(path, texture); } int[] numbers = { 1, 2, 3, 4, 5 }; foreach (int num in numbers){ Debug.Log(num); // 输出：1, 2, 3, 4, 5 } 4.4 LightmapsBuffer 缓存 #\r在 Unity 的光照烘焙流程中，我们需要对不同类型的光照贴图进行缓存、合成和保存。\n1. LightmapsBuffer：缓存的作用与实现 #\r###缓存（Buffer）###：可以理解为“存储箱”，用来临时保存不同类型的光照贴图，方便后续处理和传递。 ###枚举（enum）###：用来定义一组常量，让代码更清晰易懂。 public enum BufferType { MainLight, // 主光光照: BufferA SkyLight, // 天光光照: BufferB EmissionGI, // 自发光GI: BufferC Lightmap // 合成Lightmap } // 分别为不同类型的光照创建缓存 private Texture2D[] _bufferA; // 主光 private Texture2D[] _bufferB; // 天光 private Texture2D[] _bufferC; // 自发光 private Texture2D[] _lightmap; // 最终合成 2. 清理缓存（ClearBuffer \u0026amp; Clear） #\r###switch-case###：根据不同类型（BufferType），执行不同的清理逻辑。 ###void(类型 参数名)###： 如果是单个数据，参数名就是这个数据在函数内的临时名称 如果是集合，参数名就是这个集合在函数内的临时名称 如果是enum, 参数名就是enum内元素的临时名称。 3. 写入缓存（WriteBuffer） #\r先判断类型，若是最终 Lightmap 则直接返回。 清理对应类型的缓存。 创建新缓存，并从 info 中复制纹理。 if (type == BufferType.Lightmap) return; // 清理缓存 ClearBuffer(type); // 创建缓存并从 info 复制纹理 var lightmapsCount = info.lightmapsCount; var buffer = new Texture2D[lightmapsCount]; for (var i = 0; i \u0026lt; lightmapsCount; i++) { var lightmap = info.lightmapsInfo.Values.ElementAt(i); buffer[i] = new Texture2D(lightmap.width, lightmap.height, lightmap.format, false); Graphics.CopyTexture(lightmap, 0, 0, buffer[i], 0, 0); } info.lightmapsInfo.Values.ElementAt(i)：从字典中按顺序取出第 i 个贴图。\nTexture2D(纹理宽度,高度,格式(默认RGB24),是否生成mipmap)\nGraphics.CopyTexture：Unity API，用于高效复制贴图数据。\n4. 合成 Lightmap（CreateLightmaps） #\r依次读取主光、天光、自发光三种缓存的像素，合成到一张新的 Lightmap 上。 for (var x = 0; x \u0026lt; width; x++) { for (var y = 0; y \u0026lt; height; y++) { var colA = _bufferA[i].GetPixel(x, y); var colB = _bufferB[i].GetPixel(x, y); var colC = _bufferC[i].GetPixel(x, y); var newCol = new Color(colA.r, colB.g, colC.b, 1.0f); lightmap.SetPixel(x, y, newCol.linear); } } 每个像素点都从三张缓存贴图中取出对应颜色，合成到最终 Lightmap。 注意：缓存保存的是 Texture2D 对象，需要逐像素读取和写入。 5. 保存 Lightmap（OverrideLightmaps） #\r将合成好的 Lightmap 编码为 EXR 格式（支持 HDR），并写入磁盘。 刷新 Unity 资源数据库，让新文件被识别。 for (var i = 0; i \u0026lt; lightmapsCount; i++) { var bytes = _lightmap[i].EncodeToEXR(Texture2D.EXRFlags.CompressZIP); File.WriteAllBytes(lightmapsInfo.Keys.ElementAt(i), bytes); AssetDatabase.Refresh(); } EncodeToEXR：Unity API，将贴图编码为 EXR 格式, EXR是Unity光照系统专用的格式 Texture2D.EXRFlags.CompressZip 压缩为zip File.WriteAllBytes：.NET API，将字节数组写入文件。 lightmapsInfo.Keys.ElementAt(i)从dictionary lightmapsInfo获取第i个key,即路径 AssetDatabase.Refresh()：刷新资源数据库（仅编辑器模式下可用）。 6. 烘焙模式（BakeMode）与场景设置（ArrangeBakeScene） #\r###BakeMode###：用枚举定义不同的烘焙模式（全部、主光、天光、自发光）。 ###ArrangeBakeScene###：根据不同模式设置场景参数，如环境光类型和强度。 RenderSettings.ambientMode = AmbientMode.Skybox; RenderSettings.ambientIntensity = 1.0f; ambientMode 决定环境光类型（天空盒、渐变、单色）。 ambientIntensity 控制环境光强度（烘焙后生效）。 对应lightingSetting → lighting → Scene → Environment Lighting → Source \u0026amp; Intensity Multiplier\n设置主光为静态：\nvar staticFlags = StaticEditorFlags.ContributeGI | StaticEditorFlags.ReflectionProbeStatic; GameObjectUtility.SetStaticEditorFlags(mainlight.gameObject, staticFlags); 7. 执行烘焙（Bake）与反射探头烘焙（BakeReflectProbe） #\r###Bake###：直接调用 Unity API 进行光照烘焙。 public void Bake(BakeMode mode) { Lightmapping.Clear(); Lightmapping.Bake(); } ###BakeReflectProbe###：遍历场景所有反射探头，逐个烘焙并保存。 private void BakeReflectProbe() { var allProbe = FindObjectsOfType\u0026lt;ReflectionProbe\u0026gt;(); foreach (var probe in allProbe) { var path = AssetDatabase.GetAssetPath(probe.texture); Lightmapping.BakeReflectionProbe(probe, path); } AssetDatabase.Refresh(); } FindObjectsOfType\u0026lt;\u0026gt;()：查找场景中所有反射探头。 AssetDatabase.GetAssetPath()获取这些反射探头的贴图和路径 Lightmapping.BakeReflectionProbe()：Unity API，烘焙反射探头。 ###注###: 如果不自定义存储路径的话, 反射探头烘焙出来的Cubemap默认存在LightingData中\n4.5 LightingControllerGUI：自定义烘焙面板 #\r在了解了烘焙流程和方法后，我们还需要一个###自定义的 UI 面板###，让烘焙操作和参数调整更加直观。下面介绍 LightingControllerGUI 的实现思路和关键代码。\n1. 编辑器类的基本结构 #\r###UnityEditor.Editor###：自定义编辑器类必须继承自 Editor，并实现 OnInspectorGUI() 方法。 ###OnInspectorGUI()###：用于绘制 Inspector 面板的内容。 public class LightingControllerGUI : Editor { public override void OnInspectorGUI() { var controller = target as LightingController; if (controller == null) return; DrawFunctionButtons(controller); DrawGlobalProperties(controller); } } override 当class中的方法被设定为virtual或abstract, 只能用override引用并重写执行的内容 target as LightingController：获取当前 Inspector 绑定的对象，必须是 MonoBehaviour 派生类。 DrawFunctionButtons：绘制烘焙相关的操作按钮。 DrawGlobalProperties：绘制全局参数的调节控件。 2. 功能按钮的绘制 #\r使用 GUILayout.Button(\u0026quot;按钮名称\u0026quot;) 创建按钮，点击后执行对应方法。 EditorGUILayout.BeginHorizontal() 和 EndHorizontal() 用于让多个按钮在同一行显示。 if (GUILayout.Button(\u0026#34;禁术·多重烘培\u0026#34;)) controller.MultiBake(); EditorGUILayout.BeginHorizontal(); // 可以在这里添加更多按钮 EditorGUILayout.EndHorizontal(); 3. 全局参数的调节与监听 #\r使用 EditorGUILayout.BeginFoldoutHeaderGroup 创建可折叠的参数组。 用 EditorGUILayout.Slider 创建可拖拽的滑块，方便调整参数。 用 EditorGUI.BeginChangeCheck() 和 EndChangeCheck() 监听参数变化，变化时自动更新。 EditorGUI.BeginChangeCheck(); _groupAToggle = EditorGUILayout.BeginFoldoutHeaderGroup(_groupAToggle, \u0026#34;材质属性\u0026#34;); if (_groupAToggle) //等价于if (groupAToggle == true) { controller.metalDarken = EditorGUILayout.Slider( \u0026#34;金属压暗\u0026#34;, controller.metalDarken, 0.0f, 5.0f); } EditorGUILayout.EndFoldoutHeaderGroup(); if (EditorGUI.EndChangeCheck()) { controller.UpdateGlobalProperties(); EditorUtility.SetDirty(controller); } _groupAToggle：用于控制折叠组的展开/收起，未赋值时默认为 false。 EditorUtility.SetDirty(controller)：标记对象为“已修改”，确保参数变动能被 Unity 记录。 EmissionShaderGUI：自定义自发光参数面板 #\r通过自定义 ShaderGUI，我们可以让材质球的 Inspector 面板出现“开启自发光GI”的选项，方便控制自发光是否参与全局光照（GI）。\n1. 基本结构 #\r###继承 ShaderGUI###：自定义材质 Inspector 面板时，需要继承 ShaderGUI 类。 public class EmissionShaderGUI : ShaderGUI { // 具体实现见下方 } 继承后，Unity 会自动获取使用该脚本的 Shader 和 Material 信息。 2. 获取当前材质 #\r通过 materialEditor.target as Material 获取当前正在编辑的材质实例。 var material = materialEditor.target as Material; 3. 使用默认 Inspector 界面 #\r如果不需要自定义复杂的 UI，可以直接调用基类的 OnGUI，这样会显示默认的属性面板。 base.OnGUI(materialEditor, properties); 4. 添加自发光GI开关 #\r使用 EditorGUILayout.Toggle 创建一个勾选框，控制自发光是否参与全局光照。 Toggle有4个参数 label 文本内容 value 条件 style 按键风格 option 按键尺寸 var ifEmissionGIOn = EditorGUILayout.Toggle( \u0026#34;开启自发光GI\u0026#34;, material.globalIlluminationFlags == MaterialGlobalIlluminationFlags.AnyEmissive); material.globalIlluminationFlags = ifEmissionGIOn ? MaterialGlobalIlluminationFlags.AnyEmissive : MaterialGlobalIlluminationFlags.EmissiveIsBlack; EditorGUILayout.Toggle(\u0026quot;界面文本\u0026quot;, 条件)：根据条件显示勾选状态。 三元运算符 条件 ? 结果A : 结果B，等价于 if-else 语句： if (ifEmissionGIOn) material.globalIlluminationFlags = MaterialGlobalIlluminationFlags.AnyEmissive; else material.globalIlluminationFlags = MaterialGlobalIlluminationFlags.EmissiveIsBlack; Shader 讲解与案例分析 #\r在本案例中，Shader 与其他案例相比有以下几个关键差别：\nLightmap UV 的计算方式 MetaPass 的实现 分支声明（shader_feature） ShadowCaster 的自定义 1. Lightmap UV 的标准计算 #\r在 Unity 中，Lightmap 的 UV 坐标通常这样计算：\nfloat2 lmUV = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw; uv1 是模型的第二套 UV（专门用于光照贴图）。 unity_LightmapST 是 Unity 自动传入的缩放/偏移参数。 2. MetaPass：专用于烘焙的着色通道 #\rMetaPass 是 Unity 光照烘焙系统专用的 Shader 通道。只有带有 MetaPass 的 Shader 才能参与到光照烘焙。\n###案例代码（Building.Shader 的 MetaPass）：###\nPass { Name \u0026#34;META\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;Meta\u0026#34; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;UnityMetaPass.cginc\u0026#34; #pragma shader_feature __ _BAKE_MAINLIGHT _BAKE_SKYLIGHT _BAKE_EMISSIONGI struct VertexInput { float4 vertex : POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float2 uv2 : TEXCOORD2; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; VertexOutput vert (VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityMetaVertexPosition(v.vertex, v.uv1, v.uv2, unity_LightmapST, unity_DynamicLightmapST); o.uv = v.uv0; return o; } float4 frag(VertexOutput i) : COLOR { UnityMetaInput metaIN; UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN); metaIN.Albedo = Luminance(tex2D(_MainTex, i.uv).rgb); metaIN.SpecularColor = 0.0f; metaIN.Emission = 0.0f; return UnityMetaFragment(metaIN); } ENDCG } ###要点说明：###\nUnityStandardMeta.cgnic PBR流程META Pass专用 UnityMetaPass.cginc 属于UnityStandardMeta.cgnic的一部分, 由于案例不是PBR流程, 出于优化的考虑, 只引用该cginc. 相比 UnityStandardMeta.cgnic需要自定义顶点着色器部分 UnityMetaVertexPosition：将顶点和 UV 转换到烘焙空间。 UnityMetaInput：包含 Albedo、SpecularColor、Emission 等烘焙所需数据的数组。 UNITY_INITIALIZE_OUTPUT初始化UnityMetaInput Luminance：将颜色转为灰度，保证烘焙时只考虑明暗，不受高光和自发光影响。 分支控制（shader_feature） #\r//LightingController.cs ... case BakeMode.Default: // 关闭主光 mainlight.enabled = true; // 设置环境 RenderSettings.ambientMode = AmbientMode.Skybox; RenderSettings.ambientIntensity = 1.0f; // 设置Shader全局分支 Shader.DisableKeyword(\u0026#34;_BAKE_MAINLIGHT\u0026#34;); Shader.DisableKeyword(\u0026#34;_BAKE_SKYLIGHT\u0026#34;); Shader.DisableKeyword(\u0026#34;_BAKE_EMISSIONGI\u0026#34;); break; ... #pragma shader_feature __ _BAKE_MAINLIGHT _BAKE_SKYLIGHT _BAKE_EMISSIONGI 需要在脚本和Shader 设置全局分支 通过分支声明，可以让 Shader 针对不同烘焙模式输出不同内容。 在代码中用 #if defined(...) 进行分支判断： #if defined (_BAKE_EMISSIONGI) metaIN.Emission = opacity; #elif defined (_BAKE_MAINLIGHT) || defined (_BAKE_SKYLIGHT) metaIN.Emission = 0.0f; #endif Skybox 特殊说明 #\rSkybox 的 Shader 不需要 MetaPass，Unity 内部会自动处理天空盒的光照烘焙。 3. ShadowCaster：自定义投影 Pass #\r由于本案例场景是非封闭盒状，且法线朝内，Unity 默认的 ShadowCaster 不能正确投影。需要自定义 ShadowCaster Pass。\n###案例代码：###\nPass { Name \u0026#34;ShadowCaster\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ShadowCaster\u0026#34; } ZWrite On ZTest LEqual Cull off CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f { V2F_SHADOW_CASTER; }; v2f vert(appdata_base v) { v2f o; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } ###要点说明：###\nappdata_base：Unity 预定义的顶点输入结构，包含 POSITION、NORMAL、TEXCOORD0。 V2F_SHADOW_CASTER：输出结构, 包含投影所需的裁剪空间位置和辅助向量, 等价于: float4 pos : SV_POSITION; float3 vec : TEXCOORD0; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)：计算投影偏移，保证投影正确。 TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) float4 clipPos = UnityClipSpaceShadowCasterPos(v.vertex, v.normal); \\ o.pos = UnityApplyLinearShadowBias(clipPos); \\ o.vec = ComputeOffsetData(clipPos); SHADOW_CASTER_FRAGMENT(i) Unity内置宏, 在片段着色器中计算阴影投射 Cull off：关闭剔除，保证内表面也能投影。 ###注###: uv0: TEXCOORD0 在VertexInput里会自动识别为模型的第一套UV, 在VertexOutput, TEXCOORD0就是通用插值寄存器, 是开发者自定义的数据通道, 需要在vert中手动从输入数据计算并赋值\n","date":"31 May 2025","externalUrl":null,"permalink":"/notes/courses/zhuangdongstaintrocourse/zhuangdong_note_lightingmap/","section":"Notes","summary":"","title":"Zhuangdong_Course_Note_LightingMap","type":"notes"},{"content":"\r13 透明特效相关的四种模式 #\r1. 透混 AB (AlphaBlend) #\r###用途###： 复杂轮廓、无明确边缘的物体 半透明物体 一般特效打底 ###优点###：移动端性能较好，边缘效果自然 ###缺点###：有排序问题 Shader \u0026#34;Zhuangdong/AP1/L07/L07_AB\u0026#34; { Properties{ _MainTex (\u0026#34;RGB: 颜色 A: 透贴\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Opacity (\u0026#34;透明度\u0026#34;, range(0,1)) = 0.5 } SubShader{ Tags { \u0026#34;Queue\u0026#34; = \u0026#34;Transparent\u0026#34; //让透明物体最后渲染,防止出现后面物体消失的现象 \u0026#34;RenderType\u0026#34; = \u0026#34;Transparent\u0026#34; \u0026#34;ForceNoShadowCasting\u0026#34; = \u0026#34;True\u0026#34;//关闭投影 \u0026#34;IgnoreProject\u0026#34; = \u0026#34;True\u0026#34;//不影响投射器 } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } Blend One OneMinusSrcAlpha//声明混合方式 CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #pragma multi_compile_fwdbase_fullshadows #pragma target 3.0 uniform sampler2D _MainTex; uniform float4 _MainTex_ST; uniform half _Opacity; struct VertexInput { float4 vertex : POSITION; float2 uv0 : TEXCOORD0; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); return o; } half4 frag(VertexOutput i) : COLOR{ //固定写法 half4 var_MainTex = tex2D(_MainTex, i.uv0); half3 finalRGB = var_MainTex.rgb; half opacity = var_MainTex.a * _Opacity; return half4(finalRGB * opacity, opacity); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 2. 透叠 AD (Additive) #\r###用途###：\n发光体、辉光表现 特效提亮 ###缺点###：\n有排序问题 多层叠加易OverDraw 作为辉光效果, 通常可用后处理代替 //以AB案例为模板 ... SubShader{ ... pass{ ... Blend One One //只需要把AB案例的BlendMode修改即可 ... } ... } 3. 透切 AC (AlphaCutOut) #\r###用途###： 复杂轮廓、明确边缘（如树叶、头发、金属镂空） 卡通特效（配合抗锯齿） ###优点###：无排序问题 ###缺点###：边缘生硬，移动端性能较差 //以AB案例为模板 ... SubShader{ Tags{ \u0026#34;RenderType\u0026#34; = \u0026#34;TransparentCutout\u0026#34;//对应AC \u0026#34;ForceNoShadowCasting\u0026#34; = \u0026#34;True\u0026#34; \u0026#34;IgnoreProject\u0026#34; = \u0026#34;True\u0026#34; } pass{ ... half4 frag(VertexOutput i) : COLOR{ half4 var_MainTex = tex2D(_MainTex, i.uv0); half opacity = var_MainTex.a; clip(opacity - _Cutoff);//透明剪切 return half4(var_MainTex.rgb, 1.0); } } ... } 4. 自定义混合 Custom #\r###用途###：自定义混合公式，灵活实现特殊效果\n###组合###: Src * SrcFactor op Dst * DstFactor\n###元素###:\nSrc 源, 当前Shader绘制结果 Dst 目标, 当前Shader绘制前的背景 SrcFactor 源乘子 DstFactor 目标乘子 op 混合运算符 乘子决定相关元素以什么方式参与混合, 混合运算符决定混合的形式, 详细内容请查阅Unity官方文档\n... Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } BlendOp [_BlendOp] Blend [_BlendSrc] [_BlendDst] //在Tags后添加公式 ... 15 常见问题 #\r1. 排序问题 #\r透明物体渲染时，前后关系不明确 ###解决方法###： Detach/Attach（DDC软件修改模型顶点顺序） ZWrite Off（关闭深度写入） 2. 贴图预乘问题 #\r有的贴图资产已做预乘（BaseColor * Alpha），有的没有，混合方式需区分 AB模式：预乘用 One OneMinusSrcAlpha，不预乘用 SrcAlpha OneMinusSrcAlpha, 或在frag做乘法 AD模式：预乘可无A通道，不预乘需在frag做乘法 3. 案例GhostFlow #\r//以AB为模板 Shader \u0026#34;Zhuangdong/AP1/L08/L08_GhostFlow\u0026#34; { Properties{ _MainTex (\u0026#34;RGB: 颜色 A: 透贴\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _Opacity (\u0026#34;透明度\u0026#34;, range(0,1)) = 0.5 _WarpTex (\u0026#34;扭曲图\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _WarpInt (\u0026#34;扭曲强度\u0026#34;, range(0, 1)) = 0.5 _NoiseInt(\u0026#34;噪声强度\u0026#34;, range(0, 5)) = 0.5 _FlowSpeed (\u0026#34;流动速度\u0026#34;, range(0, 10)) = 5 } SubShader{ ... Pass { ... Blend One OneMinusSrcAlpha ... struct VertexInput { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv; o.uv1 = TRANSFORM_TEX(v.uv, _WarpTex); //开启Tiling o.uv1.y = o.uv1.y + frac(_Time.x * _FlowSpeed);//启动V轴流动 return o; } half4 frag(VertexOutput i) : COLOR{ half3 var_WarpTex = tex2D(_WarpTex, i.uv1); half2 uvBias = (var_WarpTex.rg - 0.5) * _WarpInt; half2 uv0 = i.uv0 + uvBias; half4 var_MainTex = tex2D(_MainTex, uv0); half3 finalRGB = var_MainTex.rgb; half noise = lerp(1.0, var_WarpTex.b * 2.0, _NoiseInt); noise = max(0.0, noise); half opacity = var_MainTex.a * _Opacity * noise; return half4(finalRGB * opacity, opacity); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } ###核心思路###：通过扰动贴图和流动速度参数，实现透明特效的动态变化 o.uv1.y = o.uv1.y + frac(_Time.x * _FlowSpeed); // V轴流动 half opacity = var_MainTex.a * _Opacity * noise; _Time：随时间递增的参数, 有x,y,z,w四个分量, 代表不同速度挡位 _FlowSpeed 控制流动速度 frac 取余, 这里是为了防止_Time无限增长导致出现摩尔纹 noise = lerp(1.0, var_WarpTex.b * 2.0, _NoiseInt) 保证明度不变暗 _NoiseInt 此参数数值越高, noise越清晰, 超过1时, noise对比度加强 max(0.0, noise) 防止出现负值导致颜色异常 4. 案例GhostWarp #\r//以GhostFlow为模板 ... half3 var_WarpTex = tex2D(_WarpTex, i.uv1); half2 uvBias = (var_WarpTex.rg - 0.5) * _WarpInt; half2 uv0 = i.uv0 + uvBias; half4 var_MainTex = tex2D(_MainTex, uv0); ... ###原理###：WarpTex的rg通道控制UV扰动方向，-0.5保证扰动均匀分布 ###注意###：WarpInt过大时，扰动会很突兀. 这是明暗两边灰度值差异过大导致的 14, 16 火焰与水波纹特效案例 #\r火焰特效 #\r//以GhostFlow为模板 Shader \u0026#34;Zhuangdong/AP1/L09/L09_Fire\u0026#34; { Properties{ _Mask (\u0026#34;R:外焰 G:内焰 B:透贴\u0026#34;, 2D) = \u0026#34;blue\u0026#34; {} _Noise (\u0026#34;R:Noise1 G:Noise2\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _Noise1Params (\u0026#34;Noise1 x:大小 y:流速 z:强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) _Noise2Params (\u0026#34;Noise2 x:大小 y:流速 z:强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) _color1 (\u0026#34;外焰颜色\u0026#34;, Color) = (1,1,1,1) _color2 (\u0026#34;内焰颜色\u0026#34;, Color) = (1,1,1,1) } SubShader{ ... Pass { ... Blend One OneMinusSrcAlpha ... struct VertexInput { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float2 uv2 : TEXCOORD2; }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv; o.uv1 = v.uv * _Noise1Params.x - float2(0.0, frac(_Time.x * _Noise1Params.y)); o.uv2 = v.uv * _Noise2Params.x - float2(0.0, frac(_Time.x * _Noise2Params.y)); return o; } half4 frag(VertexOutput i) : COLOR{ half warpMask = tex2D(_Mask, i.uv0).b; half var_Noise1 = tex2D(_Noise, i.uv1).r; half var_Noise2 = tex2D(_Noise, i.uv2).g; half noise = var_Noise1 * _Noise1Params.z + var_Noise2 * _Noise2Params.z; float2 warpUV = i.uv0 - float2(0.0, noise) * warpMask; half3 var_Mask = tex2D(_Mask, warpUV); half3 finalRGB = _color1 * var_Mask.r + _color2 * var_Mask.g; half opacity = var_Mask.r + var_Mask.g; return half4(finalRGB, opacity); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } ###原理###：两层Noise扰动叠加，控制火焰动态, 同时通过mask自定义内焰外焰的颜色 ###关键点###： _NoiseParams.x 控制Tiling _NoiseParams.y 控制速度 _NoiseParams.z 控制扰动强度 float2(0,0, frac()) 如果v.uv - frac()的话, 纹理会往对角线方向流动, 这是因为frac会自动识别为float2(frac(), frac()) 水波纹特效 #\r//以Fire为模板 Shader \u0026#34;Zhuangdong/AP1/L09/L09_Water\u0026#34; { Properties{ _MainTex (\u0026#34;颜色贴图\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _WarpTex (\u0026#34;扰动图\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _Speed (\u0026#34;x: 流速x y: 流速y\u0026#34;, vector) = (1.0, 1.0, 0.5, 1.0) _Warp1Params (\u0026#34;Noise1 x: 大小 y: 流速x z: 流速y w: 强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) _Warp2Params (\u0026#34;Noise2 x: 大小 y: 流速x z: 流速y w: 强度\u0026#34;, vector) = (1.0, 0.2, 0.2, 1.0) } SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } ... VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv - frac(_Time.x * _Speed);//主贴图流动 o.uv1 = v.uv * _Warp1Params.x - frac(_Time.x * _Warp1Params.yz);//扰动贴图1流动 o.uv2 = v.uv * _Warp2Params.x - frac(_Time.x * _Warp2Params.yz);//扰动贴图2流动 return o; } float4 frag(VertexOutput i) : COLOR{ half3 var_Warp1 = tex2D(_WarpTex, i.uv1).rgb;//扰动值1 half3 var_Warp2 = tex2D(_WarpTex, i.uv2).rgb;//扰动值2 half2 warp = (var_Warp1.xy - 0.5) * _Warp1Params.w + (var_Warp2.xy - 0.5) * _Warp2Params.w; float2 warpUV = i.uv0 + warp;//添加扰动值 half4 var_MainTex = tex2D(_MainTex, warpUV); return float4(var_MainTex.xyz, 1.0); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } ###原理###：主纹理UV加上两层扰动Noise，实现水面波动效果 17 ScreenUV\u0026amp;ScreenWarp #\rScreenUV #\r通过屏幕空间UV采样，实现纹理随摄像机距离变化和流动的特效。\n关键在于用视空间坐标矫正畸变，并叠加流动效果。\n//以AB为模板 ... VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.uv; float3 posVS = UnityObjectToViewPos(v.vertex).xyz;//顶点位置OS转VS o.screenUV = posVS.xy / posVS.z;//VS空间畸变矫正 float originDist = UnityObjectToViewPos(float3(0.0, 0.0, 0.0)).z;//原点位置 o.screenUV *= originDist; //o.screenUV * originDist o.screenUV = o.screenUV * _ScreenTex_ST.xy - frac(_Time.x * _ScreenTex_ST.zw);//增加tiling 和 offset 和 流动 return o; } half4 frag(VertexOutput i) : COLOR{ half4 var_MainTex = tex2D(_MainTex, i.uv); half var_ScreenTex = tex2D(_ScreenTex, i.screenUV).r; half3 finalRGB = var_MainTex.rgb; half opacity = var_MainTex.a * _Opacity * var_ScreenTex; return half4(finalRGB * opacity, opacity); } ... ###要点###:\no.screenUV 视空间矫正UV，防止深度畸变 originDist 通过原点距离控制纹理缩放。 time 叠加流动效果。 ScreenWarp #\r利用 GrabPass 获取背景，通过主纹理的某个通道扰动屏幕UV，实现半透明区域的背景扭曲（类似PS正片叠底）\nShader \u0026#34;Zhuangdong/AP1/L10/L10_ScreenWarp\u0026#34; { Properties{ _MainTex (\u0026#34;RGB: 颜色 A: 透贴\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Opacity (\u0026#34;透明度\u0026#34;, range(0,1)) = 0.5 _WarpMidVal (\u0026#34;扭曲中间值\u0026#34;, range(0, 1)) = 0.5 _WarpInt (\u0026#34;扭曲强度\u0026#34;, range(0, 3)) = 0.2 } SubShader{ ... GrabPass{ \u0026#34;_BGTex\u0026#34; } ... uniform sampler2D _BGTex; ... struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float4 grabPos : TEXCOORD1;//背景采样坐标 }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); o.grabPos = ComputeGrabScreenPos(o.pos);//针对grabpass的背景纹理采样坐标 return o; } half4 frag(VertexOutput i) : COLOR{ half4 var_MainTex = tex2D(_MainTex, i.uv0); i.grabPos.xy += (var_MainTex.b - _WarpMidVal) * _WarpInt * _Opacity; half3 var_BGTex = tex2Dproj(_BGTex, i.grabPos); //tex2Dproj是专门采样这类贴图的指令 half3 finalRGB = var_MainTex.rgb * var_BGTex; half opacity = var_MainTex.a * _Opacity; return half4(finalRGB * opacity, opacity); ... ###要点###:\nGrabPass 获取背景并保存在BGTex中 WarpMidVal 调整UV采样位置 _Opacity 透明度和i.grabPos绑定,透明度越低, 扭曲越明显 ###同类方法###:\nGrabPass: 适合高质量但性能开销大 CommandBuffer: 前Srp时代管线自定义方法 Lwrp/Urp: 后Srp时代管线自定义方法(推荐) 18. 序列帧动画（Sequence） #\r18.1 序列帧动画原理 #\r在特效制作中，常用一张包含多帧的序列帧贴图，每一帧代表动画的一个状态。通过切换UV采样区域，实现动画播放效果。\n案例贴图为3行4列，每帧依次排列。 特效层悬浮于物体表面（通过顶点沿法线方向挤出）。 UV起点为左上，需调整初始采样区域。 ###关键代码：###\n//在AB案例基础上添加一个pass ... pass{ Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } Blend One One ... VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; //顶点沿法线方向挤出 v.vertex.xyz += v.normal * 0.01; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _Sequence); //计算当前帧索引 float id = floor(_Time.z * _Speed); float idV = floor(id / _ColCount); float idU = id - idV * _ColCount; float stepU = 1.0 / _ColCount; float stepV = 1.0 / _RowCount; //uv缩放并调整起点到左上 float2 initUV = o.uv * float2(stepU, stepV) + float2(0.0, stepV * (_RowCount -1)); o.uv = initUV + float2(idU * stepU, -idV * stepV); return o; } half4 frag(VertexOutput i) : COLOR{ half4 var_Sequence = tex2D(_Sequence, i.uv); half3 finalRGB = var_Sequence.rgb; half opacity = var_Sequence.a; return half4(finalRGB * opacity, opacity); } ENDCG ... ###要点总结：###\nfloor向下取整, 比如1.9输出1 id 横向每次移动 1/_ColCount idV = floor(id / _ColCount) 当id为列数的整数倍时, idV增加1 idU = id - idV * _ColCount纵向每满一行移动 1/_RowCount, 同时idU清零 float2(idU * stepU, -idV * stepV)每次移动1/_ColCount单位, 当移动次数等于_ColCount时, idU清零回到最左边, 同时纵向移动1/_RowCount单位 ###注###: 特效算法尽量简单，避免overdraw。\n18.2 极坐标动画（PolarCoord） #\r极坐标变换可实现径向流动、扫描等特效。通过将UV从笛卡尔坐标系转换为极坐标，并叠加时间流动，实现特殊动画效果。\n###关键代码：###\nhalf4 frag(VertexOutput i) : COLOR { i.uv = i.uv - float2(0.5, 0.5); float theta = atan2(i.uv.y, i.uv.x); theta = theta / 3.1415926 * 0.5 + 0.5; float p = length(i.uv) + frac(_Time.x * 3); i.uv = float2(theta, p); half4 var_MainTex = tex2D(_MainTex, i.uv); half3 finalRGB = (1 - var_MainTex.rgb); half opacity = (1 - var_MainTex.r) * _Opacity * i.color.r; return half4(finalRGB * opacity, opacity); } 图片极坐标\n###要点总结：###\n图片atan2\natan2 计算角度θ, 结果为(-Π, Π), 归一化到[0,1]。 图片length\nlength 决定了贴图采样的起始点 float2(theta, p)UV映射到极坐标，实现径向动画。 i.color 顶点色用于柔化边缘。 19. 顶点动画（Vertex Animation） #\r19.1 平移（Translation） #\r通过正弦函数让顶点在Y轴方向周期性移动，实现整体上下浮动效果。\n//以AB为模板 ... #define TWO_PI 6.283185 void Translation (inout float3 vertex) { vertex.y += _MoveRange * sin(frac(_Time.z * _MoveSpeed) * TWO_PI); } VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; Translation(v.vertex.xyz); o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; return o; } ###要点：###\nfrac FractionalPrat, 取小数部分, 保证时间参数在[0,1]循环，防止溢出。 图片sin\nsin sin(0, 2Π)是一个从0到1再到0的周期运动。 19.2 缩放（Scale） #\r所有顶点按同一比例缩放.\n//以AB为模板 void Scaling (inout float3 vertex) { vertex.xyz *= 1.0 + _ScaleRange * sin(frac(_Time.z * _ScaleSpeed) * TWO_PI); } VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; Scaling(v.vertex.xyz); o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex); return o; } ###要点：###\n保证缩放值大于0，避免反向缩放。 19.3 旋转（Rotation） #\r顶点绕Y轴周期性旋转，实现摇头、摆动等效果。\n//以AB为模板 void Rotation (inout float3 vertex) { float angleY = _RotateRange * sin(frac(_Time.z * _Rotatepeed) * TWO_PI); float radY = radians(angleY); float sinY, cosY = 0; sincos(radY, sinY, cosY); vertex.xz = float2( vertex.x * cosY - vertex.z * sinY, vertex.x * sinY + vertex.z * cosY ); } ###要点：###\nradians 角度转弧度, 弧度写法提升性能 sincos(raY, sinY, cosY) 等价于sinY = sin(radY), cosY = cos(radY), 这种写法提高性能。 vertex.xz 旋转矩阵 M (x * cosθ - y * sinθ, x * sinθ + y * cosθ) 19.4 复合动画（AnimationGhost） #\r将缩放、平移、旋转等多种动画结合，配合顶点色实现复杂运动（如幽灵、天使圈等）。\n... //以AB为模板 void AnimGhost (inout float3 vertex, inout float3 color){ // 天使圈缩放 float scale = _ScaleParams.x * color.g * sin(frac(_Time.z * _ScaleParams.y) * TWO_PI); vertex.xyz *= 1.0 + scale; vertex.y -= _ScaleParams.z * -scale; // 幽灵摆动 float swingX = _SwingXparams.x * sin(frac(_Time.z * _SwingXparams.y + vertex.y * _SwingXparams.z) * TWO_PI); float swingZ = _SwingZparams.x * sin(frac(_Time.z * _SwingZparams.y + vertex.y * _SwingZparams.z) * TWO_PI); vertex.xz += float2(swingX, swingZ) * color.r; // 幽灵摇头 float radY = radians(_ShakeYparams.x) * (1.0 - color.r) * sin(frac(_Time.z * _ShakeYparams.y - color.g * _ShakeYparams.z) * TWO_PI); float sinY, cosY = 0; sincos(radY, sinY, cosY); vertex.xz = float2( vertex.x * cosY - vertex.z * sinY, vertex.x * sinY + vertex.z * cosY ); // 幽灵起伏 float swingY = _SwingYparams.x * sin(frac(_Time.z * _SwingYparams.y - color.g * _SwingYparams.z) * TWO_PI); vertex.y += swingY; // 处理顶点色 float lightness = 1.0 + color.g * 1.0 + scale * 2.0; color = float3(lightness, lightness, lightness); } ... ###要点：###\n顶点色R、G通道分别控制不同动画区域。\nvertex.y -= _ScaleParams.z * -scale\n缩放动画是以模型原点为中心缩放的,\n控制y轴缩放幅度, 避免天使圈离开原地\nvertex.y * _SwingXparams.z\n图片frac(time)\nsin的的结果受vertex.y影响\n_ShakeYoarams.z _SwingYparams.z让天使环和其他部分的动画, 产生时间上的滞后\nlightness 光环亮度随time变化\n20. 时钟动画（ClockAnim） #\r20.1 时钟指针动画 #\r通过C#脚本获取系统时间，驱动Shader中时针、分针、秒针的旋转，实现真实时钟动画。\n... void RotateZwithOffset(float angle, float offset, float mask, inout float3 vertex){ vertex.y -= offset * mask; float radZ = radians(angle * mask); float sinZ, cosZ = 0; sincos(radZ, sinZ, cosZ); vertex.xy = float2( vertex.x * cosZ - vertex.y * sinZ, vertex.x * sinZ + vertex.y * cosZ ); vertex.y += offset * mask; } void ClockAnim(float3 color, inout float3 vertex) { RotateZwithOffset(_HourHandAngle, _RotateOffset, color.r, vertex); RotateZwithOffset(_MinuteHandAngle, _RotateOffset, color.g, vertex); RotateZwithOffset(_SecondHandAngle, _RotateOffset, color.b, vertex); } VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; ClockAnim(v.color.rgb, v.vertex.xyz); ... ###要点###:\nangle 代表每个时间单位的旋转角度 offset 偏移旋转中心. 初始中心在模型原点, 需要调整 ###C#脚本绑定系统时间：###\nusing System; using UnityEngine; public class HelloWorld : MonoBehaviour { // --------- Public ------- public Material clockMat; // --------- private -------- private bool valid; private int hourAnglePropID; private int minuteAnglePropID; private int secondAnglePropID; // Start is called before the first frame update void Start() { if(clockMat == null) return; hourAnglePropID = Shader.PropertyToID(\u0026#34;_HourHandAngle\u0026#34;); minuteAnglePropID = Shader.PropertyToID(\u0026#34;_MinuteHandAngle\u0026#34;); secondAnglePropID = Shader.PropertyToID(\u0026#34;_SecondHandAngle\u0026#34;); if(clockMat.HasProperty(hourAnglePropID) \u0026amp;\u0026amp; clockMat.HasProperty(minuteAnglePropID) \u0026amp;\u0026amp; clockMat.HasProperty(secondAnglePropID)) valid = true; Debug.Log(\u0026#34;hourAnglePropID\u0026#34; + hourAnglePropID); Debug.Log(\u0026#34;minuteAnglePropID\u0026#34; + minuteAnglePropID); Debug.Log(\u0026#34;secondAnglePropID\u0026#34; + secondAnglePropID); Debug.Log(valid); } // Update is called once per frame void Update() { if(!valid) return; int second = DateTime.Now.Second; float secondAngle = second /60.0f * 360.0f; clockMat.SetFloat(secondAnglePropID, secondAngle); int minute = DateTime.Now.Minute; float minuteAngle = minute /60.0f * 360.0f; clockMat.SetFloat(minuteAnglePropID, minuteAngle); int hour = DateTime.Now.Hour; float hourAngle = (hour % 12) / 12.0f * 360.0f + minuteAngle / 360.0f * 30.0f; clockMat.SetFloat(hourAnglePropID, hourAngle); } } ###要点：###\n继承 编程术语, 可以让class直接使用其他class现存的方法\nclockMat 模型的材质, 继承自MonoBehaviour的class, 其脚本被允许附着在GameObject上, 并获取该GameObject的材质\n% 取余, 保证hour超过12时归0\n余数 = 被除数 - (除数 * 整数商), 比如7/3 的余数 = 7 - (3 * 2) = 1\n20.2 阴影投影Pass #\rPass { Name \u0026#34;ShadowCaster\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ShadowCaster\u0026#34; } CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include \u0026#34;UnityCG.cginc\u0026#34; uniform float _HourHandAngle, _MinuteHandAngle, _SecondHandAngle, _RotateOffset; struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float3 color : COLOR; }; struct v2f { V2F_SHADOW_CASTER; }; void RotateZwithOffset(float angle, float offset, float mask, inout float3 vertex){ vertex.y -= offset * mask; float radZ = radians(angle * mask); float sinZ, cosZ = 0; sincos(radZ, sinZ, cosZ); vertex.xy = float2( vertex.x * cosZ - vertex.y * sinZ, vertex.x * sinZ + vertex.y * cosZ ); vertex.y += offset * mask; } void ClockAnim(float3 color, inout float3 vertex) { RotateZwithOffset(_HourHandAngle, _RotateOffset, color.r, vertex); RotateZwithOffset(_MinuteHandAngle, _RotateOffset, color.g, vertex); RotateZwithOffset(_SecondHandAngle, _RotateOffset, color.b, vertex); } v2f vert(appdata v) { v2f o; ClockAnim(v.color.rgb, v.vertex.xyz); // 关键修复：计算带法线偏移的阴影坐标 float3 posWS = mul(unity_ObjectToWorld, v.vertex).xyz;//动画后的顶点转世界空间 float3 normalWS = UnityObjectToWorldNormal(v.normal);//法线转世界空间 o.pos = UnityClipSpaceShadowCasterPos(posWS, normalWS); TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } ###要点###\nShadowCaster 处理投影Pass的固定命名, 以及LightMode的固定模式\nUnityClipSpaceShadowCasterPos(posWS, normalWS) 法线偏移修正, 获得动画前的法线和动画后的顶点，来计算动画后的法线方向，最终输出动画后的顶点位置和修正后的法线在光源视锥体下的裁剪空间坐标\nV2F_SHADOW_CASTER Unity内置宏, 等价于:\nfloat4 pos : SV_POSITION float3 vec : TEXCOORD0 (只在有点光源时使用) TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) 输入posWS, normalWS, 输出V2F_SHADOW_CASTER\nSHADOW_CASTER_FRAGMENT(i) 输入pos, 根据光源类型处理投影\n###注###: 只需要 ShadowCaster, V2F_SHADOW_CASTER, TRANSFER_SHADOW_CASTER_NORMALOFFSET(o), SHADOW_CASTER_FRAGMENT(i) 4个要素就能获得一个功能完整的阴影投射Pass\n21. 特效消融动画案例 #\r21.1 灰度图与噪声控制消融 #\r通过多通道灰度图、噪声图、顶点色，实现网格消失、随机性、发光等复杂消融特效。\n###关键结构体与函数：###\nstruct VertexInput { float4 vertex : POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float4 normal : NORMAL; float4 tangent : TANGENT; float4 color : COLOR; }; struct VertexOutput { float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float2 uv1 : TEXCOORD1; float4 posWS : TEXCOORD2; float3 nDirWS : TEXCOORD3; float3 tDirWS : TEXCOORD4; float3 bDirWS : TEXCOORD5; float4 effectMask : TEXCOORD6; LIGHTING_COORDS(7,8) }; float4 CyberpunkAnim(float noise, float mask, float3 normal, inout float3 vertex){ float baseMask = abs(frac(vertex.y * _EffParams.x - _Time.x * _EffParams.y) -0.5) * 2.0; baseMask = min(1.0, baseMask * 2.0); baseMask += (noise - 0.5) * _EffParams.z; float4 effectMask = float4(0.0, 0.0, 0.0, 0.0); effectMask.x = smoothstep(0.0, 0.9, baseMask); effectMask.y = smoothstep(0.2, 0.7, baseMask); effectMask.z = smoothstep(0.4, 0.5, baseMask); effectMask.w = mask; vertex.xz += normal.xz * (1.0 - effectMask.y) * _EffParams.w * mask; return effectMask; } ###顶点着色器：###\nVertexOutput vert(VertexInput v) { float noise = tex2Dlod(_EffectMap02, float4(v.uv1, 0.0, 0.0)).r; VertexOutput o = (VertexOutput)0; o.effectMask = CyberpunkAnim(noise, v.color, v.normal.xyz, v.vertex.xyz); o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; o.uv1 = v.uv1; o.posWS = mul(unity_ObjectToWorld, v.vertex); o.nDirWS = UnityObjectToWorldNormal(v.normal); o.tDirWS = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz ); o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w); TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } ###片段着色器:###\nfloat4 frag(VertexOutput i) : COLOR{ // ...（向量、光照、采样等略）... //光照模型 float3 baseCol = var_MainTex.rgb * _BaseColor; float Lambert = max(0.0, nDotl);//lambert float specCol = var_SpecTex.rgb; float specpow = lerp(1, _SpecularPow_Value, var_SpecTex.a); float Phong = pow(max(0.0, vDotr), _SpecularPow_Value); float shadow = LIGHT_ATTENUATION(i); float3 dirlighting = (baseCol * Lambert + specCol * Phong) * _LightColor0 * shadow; float3 EnvCol = TriColAmbient(nDirWS, _TopCol, _MidCol, _BotCol); float fresnel = pow(1.0 - ndotv, _FresnelPow); float occlusion = var_MainTex.a; float3 envLighting = (baseCol * EnvCol * _EnvDiffInt + var_Cubemap * fresnel* _EnvSpecint * var_SpecTex.a) * occlusion; //自发光 float3 emission = var_EmitTex * _EmitInt; float3 _EffectMap01_var = tex2D(_EffectMap01, i.uv1).xyz; float meshMask = _EffectMap01_var.x; float faceRandomMask = _EffectMap01_var.y; float faceSlopMask = _EffectMap01_var.z; float smallMask = i.effectMask.x; float midMask = i.effectMask.y; float bigMask = i.effectMask.z; float baseMask = i.effectMask.w; float midOpacity = saturate(floor(min(faceRandomMask, 0.999999) + midMask)); float bigOpacity = saturate(floor(min(faceSlopMask, 0.999999) + bigMask)); float opacity = lerp(1.0, min(bigOpacity, midOpacity), baseMask); float meshEmitInt = (bigMask - smallMask) * meshMask;//只在半透明的区域有发光效果 meshEmitInt = meshEmitInt * meshEmitInt * 2.0;//进行固定值的power,让发光区域缩小 emission += _EffCol * meshEmitInt * baseMask; float3 FinalColor = dirlighting + envLighting + emission; return float4(FinalColor * opacity, opacity); } ###要点:###\nEffMap01 R - WireframeMap 记录模型线框 G - RandomGrayScale 记录基于面的随机灰度图 B - DisappearanceGrayscale 记录基于面的统一深度图 EffMap02 3DPerlinNoise mask 顶点色, 让动画只作用于人物 baseMask = abs(frac(vertex.y * _EffParams.x - _Time.x * _EffParams.y) -0.5) * 2.0; frac(vertex.y) 只取小数, 视觉表现为贴图 Gradient Linear 1 EffectParams.x 控制Gradient Linear 1 Tiling EffectParams.y 控制动画速度和方向 abs(frac() -0.5) * 2.0 abs取绝对值, 最终结果将 Gradient Linear 1 转变成 Gradient Linear 3 baseMask = min() 增加取值为1的范围 baseMask += (noise - 0.5) * _EffParams.z; 使baseMask取值非1的区域产生变化, _EffParams.z控制变化强度 smoothstep 对指定区域进行波形调整 vertex.xz += 对透明部分进行动画, EffParams.w控制动画强度 floor 小于1的取0, 大于1的取1 saturate 限定值域为(0, 1) meshEmitInt * meshEmitInt 等价于Power = value^2 ","date":"27 May 2025","externalUrl":null,"permalink":"/notes/courses/zhuangdongstaintrocourse/zhuangdong_note_vfxshader/","section":"Notes","summary":"","title":"Zhuangdong_Course_Note_VFXShader","type":"notes"},{"content":"\r01 一般的渲染过程 #\r渲染的基本流程如下：\nflowchart LR\r模型 --\u003e 输入结构\r输入结构 --\u003e 顶点Shader\r顶点Shader --\u003e 输出结构\r输出结构 --\u003e 像素Shader\r模型 #\r包含顶点信息（如：v 1.0 1.0 -1.0，ID由顺序决定）、三角面信息（如：f 5 3 1，数字为顶点ID），以及UV、法线、顶点色等。\n输入结构 #\r选择需要用到的模型信息。\n顶点Shader #\r处理输入信息，将每个顶点的位置换算到屏幕空间，并计算/赋值其他逐顶点信息（如UV、顶点色、法线等）。\n输出结构 #\r输出指定的顶点信息。\n像素Shader #\r结合环境、光照、摄像机等，输出最终渲染结果。\n向量、标量、点乘、兰伯特 #\r向量 #\r点乘 #\r结果在[-1,1]区间，决定明暗交界。\n兰伯特 #\rmax(0, nDir·lDir)，只取正值。\n半兰伯特 #\rLambert * 0.5 + 0.5，让暗部更柔和。\nfloat lambert = max(0.0, nDotl); float2 uv = float2(lambert, 0.0); float4 var_MainTex = tex2D(_MainTex, uv); return float4(var_MainTex); 02 案例讲解 #\r法线偏移制造复数高光 #\r利用法线的偏移，制造出多个高光区域，丰富物体表面的高光表现。\n图片 blin球加复数高光\n屏幕UV\u0026amp;深度值 #\r通过将屏幕UV与深度值相乘，可以让纹理依附于物体表面，并始终面向摄像机。\n图片 屏幕深度+纹理映射\n算法组合 #\r程序纹理 #\r通过屏幕坐标系乘以 tiling 数量，取小数后限定在 [-0.5, 0.5] 区间，再接入 Length 节点.\nPower #\r对值进行幂运算，调节高光或其他效果的形状。\n图片 程序纹理展示SD\nLength = √(x^2 + y^2 + z^2)，x=y 时，x=-0.5 或 0.5 时结果为 √0.5，x=0 时结果为 0，形成周期性循环。\n03 基础代码材质 FlatCol #\r之前的案例都是用 ShaderForge 节点方式制作，这里开始用代码实现材质. 代码实现的材质在性能和灵活性上有优势，因为最终输出的指令更精简。\n代码示例 #\rShader \u0026#34;Zhuangdong/AP1/L02/Lambert_U_01\u0026#34; { Properties{} SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } CGPROGRAM//着色器编译指令 #pragma vertex vert//声明顶点着色器 #pragma fragment frag//声明片段着色器 #include \u0026#34;UnityCG.cginc\u0026#34;//引入Unity内置CG库 #pragma multi_compile_fwdbase_fullshadows//启用阴影功能 #pragma target 3.0//指定shader模型版本 //上面这些类似上下文，但功能更多. //声明顶点着色器和片段着色器，下面的vert,frag函数才能启用. //还可以选择开启和关闭功能，比如启用阴影功能。以及指定shader模型版本 struct VertexInput { //导入模型顶点信息和法线信息 //POSITION NORMAL这类词可以看UNITY官方Document查看意思 float4 vertex : POSITION; float3 normal : NORMAL; }; struct VertexOutput { //通过上面的模型顶点信息换算成顶点屏幕位置 //模型法线信息换算成世界空间法线信息 float4 pos : SV_POSITION; float3 nDirWS : TEXCOORD0; }; VertexOutput vert(VertexInput v) { //顶点着色器固定写法 v2f vert (appdata v), Output vert (input 变量名) VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex);//模型顶点位置转换成顶点屏幕位置 o.nDirWS = UnityObjectToWorldNormal(v.normal);//法线转成世界法线 return o; } float4 frag(VertexOutput i) : COLOR{ //片段着色器固定写法 float3 nDir = i.nDirWS; float3 lDir = normalize(_WorldSpaceLightPos0.xyz); //0代表平行光，后面xyz代表方向，1代表点光，xyz代表点光坐标 //normalize归一化保证渲染结果不出错 float nDotl = (dot(nDir, lDir)*0.5+0.5);//halflambert float lambert = max(0.0, nDotl); //有的手机机型会把0视为0.1这类小数，所以最好写0.0，不然会出错。 //使用max而不是clamp,是因为clamp限制两头,max限制一头,更省性能,因为点乘不会大于1 return float4(lambert, lambert, lambert, 1.0); } ENDCG } } FallBack \u0026#34;Diffuse\u0026#34; } 自定义材质案例: #\r用float4自定义光源方向，实现自定义兰伯特模型 兰伯特模型乘以float4可自定义光源颜色 兰伯特模型乘以float可自定义光强 04 案例讲解 #\rSSS材质 #\r核心思路：用贴图和参数一起控制明暗交界的颜色和范围\n贴图U轴前半段是黑色，后半段从暗到亮渐变 通过调整参数，可以让明暗交界线附近的颜色和范围随意变化 这种效果常用于模拟生物皮肤的半透明感，叫做SSS效果 颜色生成Mask #\rstep函数可以把灰度图变成黑白分明的遮罩 自定义颜色，R/G/B通道各自和Lambert混合, 生成不同遮罩，最后混合所有遮罩输出 特殊案例 #\r可以用两组UV混合不同的贴图，再调整灰度，得到最终贴图 用Half Dir和法线点乘，能让光照随摄像机变化 灰度图和光照可以混合，结果再用round节点处理，得到只有黑白两色的分界 最后可以给黑白区域分别赋予不同颜色 Pre-Integrated Skin Shading #\rLUT（Look Up Texture）原理简述\n$$ D(\\theta) = \\frac{\\int_{-\\pi}^{\\pi} \\cos(\\theta + x) \\cdot R(2\\sin(x/2))dx}{\\int_{-\\pi}^{\\pi} R(2\\sin(x/2))dx} $$\n05 漫反射与镜面反射 #\r漫反射 #\rLambert，nDotl, 方向无关\n例：电影屏幕\n镜面反射 #\rPhong/Blinn-Phong，rDotv/nDoth, 观察方向相关\n例：车漆\n常用向量 #\rnDir 法线方向 lDir 光源方向 vDir 视方向 rDir 光的反射方向, r = reflect(-l, n) hDir 半角方向, ldir和vdir中间的向量 nDoth hDir和nDir越接近, 输出的值越接近1 高光调节 #\rPower = Value^Exp\n案例 #\r漫反射+镜面反射\n// 片段着色器示例 float3 nDir = normalize(i.nDirWS); float3 lDir = _WorldSpaceLightPos0.xyz; float3 vDir = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz); float3 rDir = reflect(-lDir, nDir); float rDotv = dot(rDir, vDir); float nDotl = dot(nDir, lDir); float Lambert = nDotl * 0.5 + 0.5; float Phong = pow(max(0.0, rDotv), _SpecularPow_Value); float3 FinalColor = _BaseColor * Lambert + Phong; return float4(FinalColor, 1.0); 注: TEXCOORD相当于GPU管线中预留给开发者使用的寄存器空位, 默认是float4\n寄存器占位符: 标记顶点数据在着色器中的输入位置 用途: 传递UV 和 自定义向量数据 06 FakeEnvReflect/葡萄/漆面金属/BRDF #\rFakeEnvReflect #\r把cloud2贴图的灰度值映射到U坐标，实现将随机灰度分布应用到光照效果上。\n葡萄 #\r用兰伯特（Lambert）加LUT贴图做漫反射，高光用Phong模型。通过cloud2贴图调整颜色和高光变化。\n漆面金属 #\r用cloud2生成遮罩，lerp混合不同材质表现。一部分有镜面反射，一部分没有。\nBRDF #\r可以理解为一个函数，输入光线、视角和表面参数，输出反射分布。Lambert和Phong都是常见的BRDF模型。\nBRDFExplorer #\r可以自定义参数，制作自己的BRDF，并查看常见Shader的源码。\n07 3ColAmbient与Shadow #\r三色环境光 #\r利用normal的三个通道, 制作Top/Side/Bottom三层遮罩\nfloat3 nDir = i.nDirWS; float TopMask = max(0.0, nDir.g); float BotMask = max(0.0, -nDir.g); float MidMask = 1 - TopMask - BotMask; float3 EnvCol = _TopCol * TopMask + _MidCol * MidMask + _BotCol * BotMask; float AO = tex2D(_AoMap, i.uv); float3 EnvLighting = EnvCol * AO; return float4(EnvLighting, 1.0); Shadow #\r//给Shader增加投影 struct VertexOutput { ... LIGHTING_COORDS(3,4)};//在VertexOutput加入LIGHT_COORDS VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; ... TRANSFER_VERTEX_TO_FRAGMENT(o)//顶点着色器加入TRANSFER_VERTEX_TO_FRAGMENT ... return o;} float4 frag(VertexOutput i) : COLOR{ float shadow = LIGHT_ATTENUATION(i);//片段着色器加入LIGHT_ATTENUATION ...} 光照构成 #\rflowchart LR\r光照 --\u003e 光源\r光照 --\u003e 环境\r光源 --\u003e 漫反射Lambert\r光源 --\u003e 镜面反射Phong\r漫反射Lambert --\u003e 遮挡Shadow\r镜面反射Phong --\u003e 遮挡Shadow\r遮挡Shadow --\u003e 结果\r环境 --\u003e 漫反射3Col\r环境 --\u003e 镜面反射Cubemap\r漫反射3Col --\u003e 遮挡AO\r镜面反射Cubemap --\u003e 遮挡AO\r遮挡AO --\u003e 结果\r08 NormalMap实现原理 #\r采样法线贴图并解码 构建TBN矩阵 切线空间法线转世界空间 输出世界空间法线 VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; o.posWS = mul(unity_ObjectToWorld, v.vertex); o.nDirWS = UnityObjectToWorldNormal(v.normal); o.tDirWS = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz );//切线方向OStoWS o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w);//根据nDir tDir求bDir TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } float4 frag(VertexOutput i) : COLOR{ //向量 float3 nDirTS = UnpackNormal(tex2D(_NormalMap, i.uv0)).rgb; float3x3 TBN = float3x3(i.tDirWS, i.bDirWS, i.nDirWS);//TBN矩阵 float3 nDirWS = normalize(mul(nDirTS, TBN));//转世界空间 09 菲涅尔、Matcap、Cubemap #\r菲涅尔 #\rnDotv, nDir和vDir垂直时输出1, 重合时输出0, 表现为模型边缘高亮\nMatcap #\rview空间法线映射BRDF的渲染结果，适合静态展示\nMatcapMap #\r圆形贴图, 这是因为MatcapMap取nDirVS的RG通道为映射值,且法线向量满足\n$$ x^2 + y^2 + z^2 = 1 $$\n只取xy,映射出来的结果会是个圆形\nCubemap #\r六面体环境贴图，Mipmap展示不同阶级的清晰度\nfloat3 vrDirWS = reflect(-vDirWS, nDirWS); float3 cubemap = texCUBElod(_CubeMap, float4(vrDirWS, _CubemapMip)); 10直播答疑 #\r魔改PBR #\rPBR的由来之一就是对表面参数的概括, Shader功能加的越多, 面板参数也就越多, 通过寻找参数之间的物理关系来减少面板参数就是PBR的内容之一. 以PBR基于物理为核修改, 叫魔改PBR. 把一些PBR的BRDF或纹理名称移植到传统模型, 那还是传统模型, 不叫魔改PBR\n手游PBS基于物理为核的意义:\n基于物理的光能守恒 基于物理的表面属性归纳 微表面理论 改变UV #\r法线贴图记录的是在切线空间的法线信息, 切线空间的主副切线方向可直观理解为, 贴图在表面处的UV轴方向, 模型不变, 切线空间变了, 记录的法线信息也会变\n11 常用参数 #\r常用参数和作用 #\r数值, 范围 _Name (\u0026ldquo;名称\u0026rdquo;, float) = deafultVal _Name (\u0026ldquo;名称\u0026rdquo;, range(min, max)) = deafultVal _Name (\u0026ldquo;名称\u0026rdquo;, int) = deafultVal 位置, 向量, 颜色 _Name (\u0026ldquo;名称\u0026rdquo;, vector) = (xVal, yVal, zVal, wVal) _Name (\u0026ldquo;名称\u0026rdquo;, color) = (rVal, gVal, bVal, aVal) 2D, 3D纹理, 环境球 _Name (\u0026ldquo;名称\u0026rdquo;, 2d) = \u0026ldquo;deafultVal\u0026rdquo; {} _Name (\u0026ldquo;名称\u0026rdquo;, 3d) = \u0026ldquo;deafultVal\u0026rdquo; {} _Name (\u0026ldquo;名称\u0026rdquo;, cube) = \u0026ldquo;deafultVal\u0026rdquo; {} [HideInInspect] 用途: 在面板上隐藏该参数 可用于: 任何参数 [HideInInspect] _FakeLightDir(\u0026ldquo;伪光方向\u0026rdquo;, vector) = (0.0, 1.0, 0.0, 1.0) [NoScaleOffset] 用途: 禁用纹理的TilingOffset面板 可用于: 纹理参数 [NoScaleOffset] _MainTex (\u0026ldquo;主贴图\u0026rdquo;, 2d) = \u0026ldquo;white\u0026rdquo; {} [Normal] 用途: 标示该纹理参数为法线贴图, 以激活相关自检功能 可用于: 2D纹理参数 例子: [Normal] _NormTex (\u0026ldquo;法线贴图\u0026rdquo;, 2d) = \u0026ldquo;bump\u0026rdquo; {} [HDR] 用途: 用于设置高动态范围颜色值; 如: 灯光颜色, 自发光颜色等; 可用于: 颜色参数 [HDR] _EmitCol (\u0026ldquo;自发光颜色\u0026rdquo;, color) = (1.0, 1.0, 1.0, 1.0) [Gamma] 用途: 用于颜色参数的色彩空间的转换; 一般用于颜色空间为Linear的项目; 可用于: 颜色参数 例子: [Gamma] _EmitCol (\u0026ldquo;自发光颜色\u0026rdquo;, color) = (1.0, 1.0, 1.0, 1.0) [PowerSlider(value)] 用途: 对范围参数做Power处理后再传入Shader; 纠正部分参数调节手感 例子: [PowerSlider(0.5)] _SpecPow (“高光次幂\u0026quot;, range(1,90)) = 30 [Header(Label)] 用途: 标签, 用于排版; 可用于: 单独使用 例子: [Header(Texture)] [Space(value)] 用途: 空行, 用于排版 可用于: 单独使用 例子:[Space(50)] 常用参数类型 #\rfixed: 11位定点数, -2.0 ~ 2.0, 精度 1/256 half: 16位浮点数, -60000 ~ 60000, 精度约3位小数 float: 32位浮点数, -3.4E38 ~ 3.4E28, 精度约6, 7位小数 int: 32位整数, 较少使用 bool: 布尔型数, 较少使用 矩阵: float2x2, float3x3, float4x4, float2x3 诸如此类格式 half2x2, half3x3, half4x4, half2x3 诸如此类格式 纹理对象: sampler2D: 2D纹理 sampler3D: 3D纹理 samplerCUBE: Cube纹理 参数使用方法 #\r原则上优先使用精度最低的数据类型\n经验 #\r世界空间位置和UV坐标, 使用float 向量, HDR颜色, 使用half; 视情况升到float LDR颜色, 简单乘子, 可使用fixed 注意要点 #\r不同平台对数据类型的支持情况不同; 一般会自动转换, 极少数情况自动转换会带来问题 部分平台上, 数据类型精度转换消耗也不小; 所以fixed也是慎用 多和图形开发商量 可访问的顶点Input数据 #\rPOSITION 顶点位置 float3 float4 TEXCOORD0 UV通道1 float2 float3 float4 TEXCOORD1 UV通道2 float2 float3 float4 TEXCOORD2 UV通道3 float2 float3 float4 TEXCOORD3 UV通道4 float2 float3 float4 NORMAL 法线方向 float3 TANGENT 切线方向 float4 COLOR 定点色 float4 常用的顶点Output数据 可自定义性相比前者要强 #\rpos 顶点位置CS float4 uv0 一般纹理UV float2 uv1 LightmapUV float2 posWS 顶点位置WS float3 nDirWS 法线方向WS half3 tDirWS 切线方向WS half3 bDirWS 副切线方向WS half3 color 定点色 fixed4 常用顶点Shader操作 #\r注: Unity2019.3.2f1版本\npos UnityObjectToClipPos(v.vertex); uv0 o.uv0 = v.uv1; o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex_ST); uv1 o.uv1 = v.uv1; o.uv1 = v.uv1 * unity_LightmapST.xy + unity_LightmapST.zw; posWS mul(unity_ObjectToWorld, v.vertex); nDirWS UnityObjectToWorldNormal(v.normal); tDirWS normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0.0)).xyz); bDirWS normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w); color o.color = v.color; 启动贴图tiling uniform sampler2D _MainTex; uniform float4 _MainTex_ST ... VertexOutput vert(VertexInput v) { ... o.uv0 = TRANSFORM_TEX(v.uv0, _MainTex);\u0026amp; o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw; ...} 功能模块化, 代码复用\n原写法 float TopMask = max(0.0, nDirWS.g); float BotMask = max(0.0, -nDirWS.g); float MidMask = 1 - TopMask - BotMask; float3 EnvCol = _TopCol * TopMask + _MidCol * MidMask + _BotCol * BotMask; 修改后 float3 TriColAmbient (float3 n, float3 uCol, float3 sCol, float3 dCol){ float uMask = max(0.0, n.g); float dMask = max(0.0, -n.g); float sMask = 1.0 - uMask - dMask; float3 envCol = uCol * uMask + sCol * sMask + dCol * dMask; return envCol; } ... float3 envCol = TriColAmbient(nDirWS, _EnvUpCol, _EnvSideCol, _EnvDownCol); ... 模块化 创建Assets\\Cgnic\\MyCgnic.cgnic\n#ifndef MY_CGINC #define MY_CGINC float3 TriColAmbient (float3 n, float3 uCol, float3 sCol, float3 dCol){ float uMask = max(0.0, n.g); float dMask = max(0.0, -n.g); float sMask = 1.0 - uMask - dMask; float3 envCol = uCol * uMask + sCol * sMask + dCol * dMask; return envCol;} #endif 在Shader CGPROGRAM下新增路径\n... CGPROGRAM ... #include \u0026#34;../cginc/MyCginc.cginc\u0026#34; ... float3 envCol = TriColAmbient(nDirWS, _EnvUpCol, _EnvSideCol, _EnvDownCol); 12 Ogre 案例 #\r本案例参考了 https://support.steampowered.com/kb/3081-QUXN-6209/dota-2-workshop-item-shader-masks?l=finnish\r, 结合实际资源，制作了一个典型的角色 Shader。\n代码示例 #\rShader \u0026#34;Zhuangdong/AP1/L06/L06_ogre_Feedback\u0026#34; { Properties{ [Header(Texture)] _MainTex (\u0026#34;RGB:基础颜色 A:透明贴图\u0026#34;, 2D) = \u0026#34;White\u0026#34; {} [Normal] _NormalMap (\u0026#34;RGB：法线贴图\u0026#34;, 2D) = \u0026#34;bump\u0026#34; {} _DetailMap (\u0026#34;RGB: Detail细节贴图 A: 细节遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _MetalnessMask (\u0026#34;金属遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _SelfIllMask (\u0026#34;SelfIll自发光遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _SpecTex (\u0026#34;RGB:Spec高光贴图\u0026#34;, 2D) = \u0026#34;gray\u0026#34; {} _RimLight (\u0026#34;Rim边缘光遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _BaseTintMask (\u0026#34;Tint底色遮罩\u0026#34;, 2D) = \u0026#34;White\u0026#34; {} _SpecularExponent (\u0026#34;SpecExpo镜面反射指数\u0026#34;, 2D) = \u0026#34;White\u0026#34; {} _DiffuseWarp (\u0026#34;Diffuse扩散遮罩\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} _CubeMap (\u0026#34;RGB:Cube环境贴图\u0026#34;, Cube) = \u0026#34;_Skybox\u0026#34; {} _FresnelWarp(\u0026#34;菲涅尔贴图 R:FCol G:FRim B:FSpec\u0026#34;, 2D) = \u0026#34;black\u0026#34; {} [Header(Diffuse)] _LightCol (\u0026#34;主光颜色\u0026#34;, Color) = (1.0,1.0,1.0,1.0) [Space(10)] _TopCol (\u0026#34;顶部颜色\u0026#34;, Color) = (0.47,0.96,1,1) _MidCol (\u0026#34;中部颜色\u0026#34;, Color) = (0.46,0.7,0.45,1) _BotCol (\u0026#34;底部颜色\u0026#34;, Color) = (0.75,0.39,0.39,1) _EnvDiffInt (\u0026#34;EnvDiff环境漫反射强度\u0026#34;, Range(0.0, 5.0)) = 0.2 [Header(Specular)] _SpecPow(\u0026#34;高光次幂\u0026#34;, Range(0.0, 90.0)) = 5 _SpecInt(\u0026#34;高光强度\u0026#34;, Range(0.0, 10.0)) = 5 [Space(10)] _EnvSpecint (\u0026#34;Envspec环境镜反强度\u0026#34;, Range(0.0, 10.0)) = 0.2 [Header(SelfIll)] _SelfIllInt (\u0026#34;SelfIll自发光强度\u0026#34;, Range(0, 10)) = 1 [HDR]_RimCol (\u0026#34;轮廓光颜色\u0026#34;, Color) = (1.0,1.0,1.0,1.0) _RimInt (\u0026#34;轮廓光强度\u0026#34;, Range(0.0, 3.0)) = 1.0 [HideInInspector] _Cutoff (\u0026#34;Alpha cutoff\u0026#34;, Range(0,1)) = 0.5 [HideInInspector] _Color (\u0026#34;Main Color\u0026#34;, Color) = (1,1,1,1)//Fallback Require } SubShader{ Tags { \u0026#34;RenderType\u0026#34; = \u0026#34;Opaque\u0026#34; } Pass { Name \u0026#34;FORWARD\u0026#34; Tags { \u0026#34;LightMode\u0026#34; = \u0026#34;ForwardBase\u0026#34; } Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;AutoLight.cginc\u0026#34;//自动处理光照衰减来进行阴影处理 #include \u0026#34;Lighting.cginc\u0026#34;//主要用于访问环境主平行光相关数据 #pragma multi_compile_fwdbase_fullshadows //启用阴影功能 #pragma target 3.0 //Texture uniform sampler2D _MainTex; uniform sampler2D _NormalMap; uniform sampler2D _DetailMap; uniform sampler2D _MetalnessMask; uniform sampler2D _SelfIllMask; uniform sampler2D _SpecTex; uniform sampler2D _RimLight; uniform sampler2D _BaseTintMask; uniform sampler2D _SpecularExponent; uniform sampler2D _DiffuseWarp; uniform samplerCUBE _CubeMap; uniform sampler2D _FresnelWarp; //Diffuse uniform half3 _LightCol; uniform fixed3 _TopCol; uniform fixed3 _MidCol; uniform fixed3 _BotCol; uniform fixed _EnvDiffInt; //Specular uniform half _SpecPow; uniform half _SpecInt; uniform half _EnvSpecint; //SelfIll uniform fixed _SelfIllInt; uniform half3 _RimCol; uniform half _RimInt; uniform half _Cutoff; struct VertexInput { Document查看意思 float4 vertex : POSITION; float2 uv0 : TEXCOORD0; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct VertexOutput { 法线信息 float4 pos : SV_POSITION; float2 uv0 : TEXCOORD0; float3 posWS : TEXCOORD1; float3 nDirWS : TEXCOORD2; float3 tDirWS : TEXCOORD3; float3 bDirWS : TEXCOORD4; LIGHTING_COORDS(5,6) }; VertexOutput vert(VertexInput v) { VertexOutput o = (VertexOutput)0; o.pos = UnityObjectToClipPos(v.vertex); o.uv0 = v.uv0; o.posWS = mul(unity_ObjectToWorld, v.vertex); o.nDirWS = UnityObjectToWorldNormal(v.normal); o.tDirWS = normalize( mul( unity_ObjectToWorld, float4( v.tangent.xyz, 0.0 ) ).xyz ); o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w); TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } float4 frag(VertexOutput i) : COLOR{ //向量 half3 nDirTS = UnpackNormal(tex2D(_NormalMap, i.uv0)).rgb; half3x3 TBN = float3x3(i.tDirWS, i.bDirWS, i.nDirWS); half3 nDirWS = normalize(mul(nDirTS, TBN)); half3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz); half3 vrDirWS = reflect(-vDirWS, nDirWS); half3 lDirWS = _WorldSpaceLightPos0.xyz; 表点光坐标，归一化比较安全，点乘结果会比较正确点 half3 lrDirWS = reflect(-lDirWS, nDirWS); float shadow = LIGHT_ATTENUATION(i); //点乘 half rDotv = dot(vDirWS, lrDirWS);//Phong half nDotl = dot(nDirWS, lDirWS);//Lambert half ndotv = dot(nDirWS, vDirWS); //采样纹理 half4 var_MainTex = tex2D(_MainTex, i.uv0); half4 var_DetailMap = tex2D(_DetailMap, i.uv0); half var_MetalnessMask = tex2D(_MetalnessMask, i.uv0); half var_SelfIllMask = tex2D(_SelfIllMask, i.uv0); half var_SpecTex = tex2D(_SpecTex, i.uv0);//specInt half var_RimLight = tex2D(_RimLight, i.uv0); half var_BaseTintMask = tex2D(_BaseTintMask, i.uv0); half var_SpecularExponent = tex2D(_SpecularExponent, i.uv0);//specSize half3 var_Cubemap = texCUBElod(_CubeMap, float4(vrDirWS, lerp(8.0, 0.0, var_MetalnessMask))).rgb; half3 var_FresnelWarp = tex2D(_FresnelWarp, ndotv); //提取信息 half3 BaseCol = var_MainTex.rgb; half Opacity = var_MainTex.a; half MetalMask = var_MetalnessMask; half RimLightInt = var_RimLight; half TintMask = var_BaseTintMask; half SpecExp = var_SpecularExponent; half3 EnvCube = var_Cubemap; half SpecInt = var_SpecTex; half EmitInt = var_SelfIllMask; //光照模型 half3 DiffCol = lerp(BaseCol, half3(0.0,0.0,0.0), MetalMask); //越接近金属, 漫反射越弱 half3 SpecCol = lerp(BaseCol, half3(0.3,0.3,0.3), TintMask); //根据TintMask决定高光颜色 //0.3是经验值，这个值乘以高光强度specInt得到的高光颜色贴图比较舒服 //菲涅尔 half3 Fresnel = lerp(var_FresnelWarp, 0.0, MetalMask); //金属度越高，菲涅尔现象越不明显； half FreCol = Fresnel.r; //无实际用途 half FreRim = Fresnel.g; //轮廓光用Fresnel half FreSpec = Fresnel.b; //镜面反射用Fresnel //主光漫反射 half HalfLambert = nDotl * 0.5 + 0.5;//Halflambert half3 var_DiffuseWarp = tex2D(_DiffuseWarp, half2(HalfLambert, 0.2)); //对Ramptexture进行采样 half3 DirDiff = DiffCol * var_DiffuseWarp * _LightCol; //主光镜面反射 half Phong = pow(max(0.0, rDotv), SpecExp * _SpecPow); half Spec = Phong * max(0.0,nDotl); Spec = max(Spec, FreSpec); //会有个油亮的视觉效果, 强烈的菲涅尔现象和Phong混合在一起 Spec = Spec * _SpecInt; //乘以SpecInt后, 大部分之前Spec的效果会消失, 只有SpecInt指定的范围才有亮点 //原Shader是将所有镜面反射整合在一起最后再max(flMetalnessMask, flSpecWarp) //这里作者对镜面反射进行拆分, 所以两边最后结算都需要进行一次max half3 DirSpec = SpecCol * Spec * _LightCol; //环境漫反射 float TopMask = max(0.0, nDirWS.g); float BotMask = max(0.0, -nDirWS.g); float MidMask = 1 - TopMask - BotMask; float3 EnvCol = _TopCol * TopMask + _MidCol * MidMask + _BotCol * BotMask; float3 EnvDiff = DiffCol * EnvCol * _EnvDiffInt; //视频作者只用了单色, 这里我是直接复制之前的案例代码没有改 //环境镜面反射 half ReflectInt = max(FreSpec, MetalMask) * SpecInt; //金属部分MetalMask最大, 非金属FreSpec最大 //这样非金属有很强的菲涅尔现象, 金属部分则很少, 取而代之的有很强的反射现象 half3 EnvSpec = SpecCol * ReflectInt * EnvCube * _EnvSpecint; //轮廓光 half3 RimLight = _RimCol * FreRim * RimLightInt * max(0.0, nDirWS.g) * _RimInt; //轮廓光只出现在顶部，所以需要用normal.g //FreRim定义菲涅尔现象, RimLightInt定义强度范围, RimInt定义强度 //自发光 float3 emission = EmitInt * DiffCol * _SelfIllInt; //Final half3 FinalRGB = (DirDiff + DirSpec) * shadow + EnvDiff + EnvSpec + RimLight + emission; clip(Opacity - _Cutoff);//小于_Cutoff全部删去，大于的保留 return float4(FinalRGB, 1.0); } ENDCG } } Fallback \u0026#34;Legacy Shaders/Transparent/Cutout/VertexLit\u0026#34; //注: 使用FallBack必须声明一个_Color: 颜色, 即使你用不到 } 主要问题 #\rFallback 设置：指定到支持透明贴图的 Shader（如 Legacy Shaders/Transparent/Cutout/VertexLit）。 Cull Off：关闭背面剔除，防止模型背面被裁剪。 贴图讲解 #\r非共用贴图: #\rColor MatelnessMask Normal RimMask SelfIllumMask SpecularExponent SpecularMask TintByBaseMask Translucency 共用贴图 #\rCubemap DiffuseWarp RampTex FresnelWarpColor FresnelWarpRim FresnelWarpSpec 贴图合并 #\rColor: RGB: Color A: Opacity Mask1: R: SpecInt G: RimInt B: TintMask A: SpecPow Mask2: R:FresnelCol G: FresnelRim B: FresnelSpec 贴图说明 #\rMetalnessMask：金属遮罩，控制金属区域 SpecularMask：高光强度遮罩 RimlightMask：边缘光遮罩 BaseTintMask：高光染色遮罩，决定不同材质的高光颜色 其他贴图如 ColorMap, Tramsparency, NormalMap, SelfIlluminationMask, SpecularExponent, DiffuseMask, DetailMask 之前案例接触过, 或该案例不使用, 不赘述 源代码说明 #\rRimLightScale、SpecScale：为固定值，不同角色设定不同，主要用于边缘光和高光计算.\nSpecularScale, RimLightScale和其他源代码有的参数, 作者在不影响最终效果的情况下移除了, 并对代码进行了简化\n菲涅尔与边缘光: 不同角色RimLightScale设定不同, 大部分是大于1的数字, 在这基础下, 通过 FresnelWarp 贴图和 RimMask 控制边缘高光的强度和范围，能实现夸张的卡通边缘效果。\nFresnelWarpSpec在原Shader被称为flSpecWarp, 用于定义角色的环境镜面反射\n高光与金属控制：金属部分用 cubemap 反射，非金属部分用高光贴图控制。通过 cSpecular *= max(flMetalnessMask, flSpecWarp); 实现金属和非金属的高光切换。\n主光镜面反射：Dota2 采用了更适合俯视视角的算法，核心代码如下：\nvec3 R = reflect (V, N); float RdotL = clamp(dot(L, -R), 0, 1); 由此我们可能知道, R和L越接近, 光越亮. 相比传统 Phong，更适合 Dota2 这种上帝视角。\n光照构成 #\rflowchart LR\r光照 --\u003e 光源\r光源 --\u003e 漫反射(HalfLambert + WarpTex/Lambert)\r光源 --\u003e 镜面反射(Phong + FresnelSpecWarp) 漫反射(HalfLambert + WarpTex/Lambert) --\u003e 遮挡(Shadow)\r镜面反射(Phong + FresnelSpecWarp) --\u003e 遮挡(Shadow)\r遮挡(Shadow) --\u003e 结果\r光照 --\u003e 环境\r环境 --\u003e 漫反射(1Col)\r环境 --\u003e 镜面反射(Cubemap)\r漫反射(1Col) --\u003e 遮挡(无AO,部分成分用RimMask代替)\r镜面反射(Cubemap) --\u003e 遮挡(无AO,部分成分用RimMask代替)\r遮挡(无AO,部分成分用RimMask代替) --\u003e 结果\r轮廓光(FresnelRimWarp) --\u003e 结果\r自发光 --\u003e 结果\r经验总结 #\r视频案例将原代码拆分并融入自己的体系，便于理解和扩展. 初学时容易忽略 Fresnel 贴图的作用，建议多参考 Dota2 原始 Shader 和社区资源，理解每张贴图的实际用途。\n","date":"27 May 2025","externalUrl":null,"permalink":"/notes/courses/zhuangdongstaintrocourse/zhuangdong_note_forwardrendering/","section":"Notes","summary":"","title":"庄懂的技术美术入门课 - 前向渲染","type":"notes"},{"content":"\r07-点积与对偶性 #\r点积的几何意义\n两个向量 $\\vec{V}$ 和 $\\vec{W}$ 的点积, 等于 $\\vec{W}$ 在 $\\vec{V}$ 方向上的投影长度乘以 $\\vec{V}$ 的长度. 公式: $$(x_1, y_1) \\cdot (x_2, y_2) = x_1x_2 + y_1y_2$$ 点积结果的符号: $\\vec{W}$ 的投影方向与 $\\vec{V}$ 相同, 点积为正. $\\vec{W}$ 的投影方向与 $\\vec{V}$ 相反, 点积为负. $\\vec{W}$ 与 $\\vec{V}$ 垂直, 点积为零. 点积满足交换律: $\\vec{V} \\cdot \\vec{W} = \\vec{W} \\cdot \\vec{V}$. 假设W和V是长度相同的两个向量,它们在一条线上是对称的,此时V变成2倍长,W投影在V的长度不变,V投影在W上变成2倍 长\n此时:\n$2(\\vec{V}) \\cdot \\vec{W} = 2(\\vec{V} \\cdot \\vec{W})$\n图片2vw.py\n对偶性\n一个二维向量经过 $1 \\times 2$ 矩阵变换的结果, 与两个二维向量点积的结果相同.\n一个向量投影到另一个向量上, 这个过程可以视作一种线性变换\n例: $[1, -2] \\begin{bmatrix}4 \\ 3\\end{bmatrix} = \\begin{bmatrix}1 \\ -2\\end{bmatrix} \\cdot \\begin{bmatrix}4 \\ 3\\end{bmatrix}$\n假设存在单位向量 $\\vec{U}$, 基向量 $i, j$ 在这个向量上的投影为 $U_x, U_y$, 则投影矩阵为 $[U_x, U_y]$.\n任意向量通过 $[U_x, U_y]$ 变换到该直线, 或与 $\\vec{U}$ 点积, 计算结果相同.\n$\\vec{U}$ 与单位向量 $i$ 点积, 等于 $\\vec{U}$ 在 $i$ 方向上的投影长度.\n图片duality.py\n若 $\\vec{U}$放大为原来的3倍, 如 $[3U_x, 3U_y]$, 结果等于投影值乘以 3. 这种现象称为\u0026quot;对偶性\u0026quot;, 即矩阵向量乘积与点积之间的自然对应关系. 08-叉积 #\r第一部分: 叉积的标准介绍 #\r给定向量 $\\vec{V}$ 和 $\\vec{W}$, 将它们分别平移到对方终点, 形成一个平行四边形的平面. 叉积结果是垂直于这个平面的向量, 长度等于平面面积. 叉积产生的新向量朝向由右手定则确定. 叉积的符号: $\\vec{V}$ 在 $\\vec{W}$ 右侧, 结果为正. $\\vec{V}$ 在 $\\vec{W}$ 左侧, 结果为负. 公式(二维): $$ \\det\\left(\\begin{bmatrix}X_1 \u0026amp; Y_1 \\ X_2 \u0026amp; Y_2\\end{bmatrix}\\right) = X_1Y_2 - X_2Y_1 $$ 公式(三维): $$(V_1, V_2, V_3) \\times (W_1, W_2, W_3) = (V_2W_3 - V_3W_2, V_3W_1 - V_1W_3, V_1W_2 - V_2W_1)$$ 特点: 两向量越接近垂直, 面积越大. 其中一个向量放大, 面积也按比例放大. 结果为负, 表示坐标系取向发生翻转. 第二部分: 以线性变换的视角看叉积 #\r定义一个三维空间到一维的线性变换: 图片crossproduct.py\n存在基向量$\\vec{V}\\vec{W}$, 任意向量$\\vec{U}$\n$$ \\vec{U} = \\begin{bmatrix}x \\ y \\ z\\end{bmatrix}, f((x, y, z)) = \\det\\left(\\begin{bmatrix}x \u0026amp; y \u0026amp; z \\ V_1 \u0026amp; V_2 \u0026amp; V_3 \\ W_1 \u0026amp; W_2 \u0026amp; W_3\\end{bmatrix}\\right) $$\n存在一个向量 $\\vec{P}$, 使得: $$\\begin{bmatrix}P_1 \\ P_2 \\ P_3\\end{bmatrix} \\cdot \\begin{bmatrix}x \\ y \\ z\\end{bmatrix} = \\det\\left(\\begin{bmatrix}x \u0026amp; y \u0026amp; z \\ V_1 \u0026amp; V_2 \u0026amp; V_3 \\ W_1 \u0026amp; W_2 \u0026amp; W_3\\end{bmatrix}\\right)$$\n垂直于基向量$\\vec{V}\\vec{W}$的轴为$K$\n三维空间中, 平行六面体的体积, 由 $\\vec{U}$ 在 $K$ 上的投影长度和$\\vec{V}\\vec{W}$构成的平面面积决定.\n$\\vec{P} \\cdot \\vec{U} = |\\vec{P}| \\times \\vec{U}_{\\text{\\scriptsize 投影于P}}$\n$|\\vec{P}| \\times \\vec{U}{\\text{\\scriptsize 投影于P}}$ = $\\vec{V}\\vec{W}$ 构成平面面积 × $\\vec{U}{\\text{\\scriptsize 投影于K}}$.\n由此可得, $\\vec{P}$ 垂直于 $\\vec{V}\\vec{W}$ 构成的平面, 长度等于该平面面积, 因此等式成立.\n","date":"25 May 2025","externalUrl":null,"permalink":"/notes/foundation/linearalgebra/essenceoflinearalgebra_part3/","section":"Notes","summary":"","title":"EssenceOfLinearAlgebra_Part3","type":"notes"},{"content":"\r09-基变换 #\r我们之前讨论的各种情况,都是在标准基向量 $\\hat{i} = \\begin{bmatrix} 1 \\ 0 \\end{bmatrix}$ 和 $\\hat{j} = \\begin{bmatrix} 0 \\ 1 \\end{bmatrix}$ 定义的坐标系中进行的.\n在不同的坐标系中,描述同一个向量的坐标是不同的,这是因为我们选用的基向量发生了改变.\n###示例:### 假设有另一组基向量 $\\hat{i}\u0026rsquo; = \\begin{bmatrix} 2 \\ 1 \\end{bmatrix}$ 和 $\\hat{j}\u0026rsquo; = \\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$.\n在该坐标系中的向量 $\\begin{bmatrix} 5/3 \\ 1/3 \\end{bmatrix}$, 在我们的标准坐标系中被表示为 $\\begin{bmatrix} 3 \\ 2 \\end{bmatrix}$.\n###从其他坐标系到标准坐标系###\n图片basicchange.py\n我们可以将新的基向量构成一个矩阵 $A = \\begin{bmatrix} 2 \u0026amp; -1 \\ 1 \u0026amp; 1 \\end{bmatrix}$. 用这个矩阵乘一个在其他坐标系下的向量, 就能得到它在标准坐标系下的表示. $$\\begin{bmatrix} 2 \u0026amp; -1 \\ 1 \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} 5/3 \\ 1/3 \\end{bmatrix} = \\begin{bmatrix} 3 \\ 2 \\end{bmatrix}$$\n###从标准坐标系到其他坐标系###\n只需取上述矩阵 $A$ 的逆矩阵 $A^{-1}$. 用 $A^{-1}$ 乘一个标准坐标系下的向量, 就能得到它在其他坐标系下的表示. ###问题: 如何在两个不同的坐标系中实现相同的变换?### (例如逆时针旋转90°)\n图片inverbasic.py\n假设 $M$ 是标准坐标系下的变换矩阵 (旋转90°: $M = \\begin{bmatrix} 0 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix}$). 假设 $A$ 是从其他坐标系到标准坐标系的变换矩阵. 在其他坐标系中实现同样变换的矩阵为 $A^{-1}MA$. 这个操作的直观理解是:\n$A$: 将向量从其他坐标系变换到标准坐标系. $M$: 在标准坐标系中进行旋转. $A^{-1}$: 将结果变换回原来的坐标系. 对于基向量为 $\\begin{bmatrix} 2 \\ 1 \\end{bmatrix}$ 和 $\\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$ 的坐标系, 其旋转90°的变换矩阵为: $A^{-1}MA = \\begin{bmatrix} 2 \u0026amp; -1 \\ 1 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 0 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} 1/3 \u0026amp; 1/3 \\ -1/3 \u0026amp; 2/3 \\end{bmatrix} = \\begin{bmatrix} 1/3 \u0026amp; -5/3 \\ 2/3 \u0026amp; -1/3 \\end{bmatrix}$\n10-特征向量与特征值 #\r###特征向量 (Eigenvector)###\n在经历矩阵所描述的线性变换时, ###方向保持不变### (仅在其张成的空间内伸缩) 的非零向量. ###特征值 (Eigenvalue)###\n特征向量在变换过程中被###拉伸或压缩的比例因子###. 从几何上看, 如果一个三维空间的旋转可以被看作是围绕一个轴进行的, 那么这个轴的方向向量就是一个特征向量, 其对应的特征值为1 (因为它在旋转中没有被拉伸). 这种理解方式远比一个3x3矩阵要直观.\n###计算方法### 公式: $A\\vec{v} = \\lambda\\vec{v}$\n$A$: 变换矩阵 $\\vec{v}$: 特征向量 $\\lambda$: 特征值 为了求解, 我们将公式变形: $A\\vec{v} - \\lambda\\vec{v} = 0$ $A\\vec{v} - \\lambda I\\vec{v} = 0$ $(A - \\lambda I)\\vec{v} = 0$\n这个结果说明, 特征向量 $\\vec{v}$ 经过 $(A - \\lambda I)$ 变换后, 会被压缩成零向量. 这意味着变换 $(A - \\lambda I)$ 是一个降维的变换, 所以它的行列式必定为零. $\\det(A - \\lambda I) = 0$ ###示例:###\n图片eigenvector.py\n对于矩阵 $A = \\begin{bmatrix} 3 \u0026amp; 1 \\ 0 \u0026amp; 2 \\end{bmatrix}$: $\\det(A - \\lambda I) = \\det \\left( \\begin{bmatrix} 3 \u0026amp; 1 \\ 0 \u0026amp; 2 \\end{bmatrix} - \\lambda \\begin{bmatrix} 1 \u0026amp; 0 \\ 0 \u0026amp; 1 \\end{bmatrix} \\right) = \\det \\begin{bmatrix} 3-\\lambda \u0026amp; 1 \\ 0 \u0026amp; 2-\\lambda \\end{bmatrix} = (3-\\lambda)(2-\\lambda) = 0$ 解得特征值 $\\lambda = 2$ 或 $\\lambda = 3$.\n当 $\\lambda = 2$ 时, 我们求解 $(A - 2I)\\vec{v}$ = $\\begin{bmatrix} 1 \u0026amp; 1 \\ 0 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} = \\begin{bmatrix} 0 \\ 0 \\end{bmatrix}$ 所有解都在向量 $\\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$ 所张成的空间上.\n当 $\\lambda = 3$ 时, 矩阵 $\\begin{bmatrix} 3 \u0026amp; 1 \\ 0 \u0026amp; 2 \\end{bmatrix}$ 会将对应的特征向量拉伸为原来的3倍.\n###特性与应用###\n###并非所有变换都有特征向量###: 例如, 二维空间中逆时针旋转90°的变换就没有实数域上的特征向量. ###存在多个特征向量的变换###: 例如, 缩放矩阵 ###对角矩阵###: 如果一个变换的基向量恰好都是特征向量, 那么描述该变换的矩阵是一个###对角矩阵###, 矩阵的对角元就是这些基向量对应的特征值. ###简化高次幂计算###: 对角矩阵的幂次计算非常简单, 只需计算其对角元(特征值)的相应幂次即可. 当我们需要多次计算一个非对角矩阵 $M$ 时, 如果它有足够的特征向量, 我们可以: 将特征向量作为新的基向量, 构成基变换矩阵 $A$. 通过 $A^{-1}MA$ 将 $M$ 转换为对角矩阵 $D$. 计算 $D^n$. 通过 $A D^n A^{-1}$ 将结果转换回原坐标系, 即 $M^n = A D^n A^{-1}$. 11-抽象向量空间 #\r向量和函数有共同点.\n###函数作为向量###\n###线性性质###: 许多对函数的操作 (如求导) 都是线性的, 即满足:\n###可加性###: $L(f + g) = L(f) + L(g)$ ###成比例###: $L(cf) = cL(f)$ ###多项式的向量表示###: 我们可以将多项式看作一个维度无限的向量.\n以一组基函数 $b_0(x)=1, b_1(x)=x, b_2(x)=x^2, \\dots$ 为例. $1x^2 + 3x + 5 \\cdot 1$ 可以视为向量 $\\begin{bmatrix} 5, 3, 1, 0, \\dots \\end{bmatrix}^T$. $4x^7 - 5x^2$ 可以视为向量 $\\begin{bmatrix} 0, 0, -5, 0, 0, 0, 0, 4, \\dots \\end{bmatrix}^T$. ###求导的矩阵表示###: 求导这个变换也可以用矩阵来描述.\n$\\frac{d}{dx}(a_n x^n + \\dots + a_1 x + a_0) = n a_n x^{n-1} + \\dots + a_1$ 这个变换作用在多项式对应的向量上, 就像一个矩阵作用于一个向量. ###八条公理###\n之所以会这样, 是因为向量计算和函数计算都符合这八条公理:\n###向量加法结合律###: $U + (V + W) = (U + V) + W$ ###向量加法交换律###: $V + W = W + V$ ###加法单位元存在###: 存在一个零向量 $0$, 使得 $0 + V = V$ ###加法逆元存在###: 对任意向量 $V$, 存在 $-V$, 使得 $V + (-V) = 0$ ###标量乘法与域乘法相容###: $a(bV) = (ab)V$ ###标量乘法单位元存在###: $1V = V$ ###标量乘法对向量加法分配律###: $a(V + W) = aV + aW$ ###标量乘法对域加法分配律###: $(a + b)V = aV + bV$ ","date":"25 May 2025","externalUrl":null,"permalink":"/notes/foundation/linearalgebra/essenceoflinearalgebra_part4/","section":"Notes","summary":"","title":"EssenceOfLinearAlgebra_Part4","type":"notes"},{"content":"\r03-矩阵与线性变换 #\r什么是线性变换\n你可以把它理解成一种函数, 即意味着有输出和输入, 输入一个向量, 输出一个向量, 中间的计算, 即变换过程体现了向量的运动规律.\n特征:\n直线在变换后依旧是直线 (包裹向量构成的对角线) 原点位置不变 网格线保持平行且等距分布 图片lineartransform.py 线性变换\n图片nonlineartransform.py 非线性变换\n例子\n我们可以通过数值来描述线性变换\n原始基向量: $\\hat{i} = \\begin{bmatrix} 1 \\ 0 \\end{bmatrix}$, $\\hat{j} = \\begin{bmatrix} 0 \\ 1 \\end{bmatrix}$\n考虑坐标为 (-1, 2) 的向量 $\\vec{v}$ 时: $ \\vec{v} = -1 \\hat{i} + 2 \\hat{j} = -1 \\begin{bmatrix} 1 \\ 0 \\end{bmatrix} + 2 \\begin{bmatrix} 0 \\ 1 \\end{bmatrix} = \\begin{bmatrix} -1 \\ 2 \\end{bmatrix} $\n如果运用一些变换, 基向量会和向量 $\\vec{v}$一起运动\n变换后的基向量: $\\hat{i}\u0026rsquo; = \\begin{bmatrix} 1 \\ -2 \\end{bmatrix}$, $\\hat{j}\u0026rsquo; = \\begin{bmatrix} 3 \\ 0 \\end{bmatrix}$\n$ \\vec{v}\u0026rsquo; = -1 \\hat{i}\u0026rsquo; + 2 \\hat{j}\u0026rsquo; = -1 \\begin{bmatrix} 1 \\ -2 \\end{bmatrix} + 2 \\begin{bmatrix} 3 \\ 0 \\end{bmatrix} = \\begin{bmatrix} -1 \\cdot 1 + 2 \\cdot 3 \\ -1 \\cdot (-2) + 2 \\cdot 0 \\end{bmatrix} = \\begin{bmatrix} 5 \\ 2 \\end{bmatrix} $\n由此得出, 我们可以通过$\\hat{i}\u0026rsquo;$和$\\hat{j}\u0026rsquo;$来推断$\\vec{v}$变换后的落脚点\n图片lineartranformex.py\n一个二维线性变换仅由四个数字完全确定, 也就是变换后的$\\hat{i}\u0026rsquo;$和$\\hat{j}\u0026rsquo;$的坐标, 通常我们将这些坐标包装在一个 2X2 的格子中, 称它为 2X2 矩阵\n只需输入一个向量$\\begin{bmatrix} -1 \\ 2 \\end{bmatrix}$, 我们就可以通过$\\begin{bmatrix} 1 \u0026amp; 3 \\ -2 \u0026amp; 0 \\end{bmatrix}$得到变换后的向量$\\begin{bmatrix} 5 \\ 2 \\end{bmatrix}$\n公式\n$$ \\begin{bmatrix} a \u0026amp; b \\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} = x \\begin{bmatrix} a \\ c \\end{bmatrix} + y \\begin{bmatrix} b \\ d \\end{bmatrix} = \\begin{bmatrix} ax + by \\ cx + dy \\end{bmatrix} $$\n常用矩阵\n图片generaltransform.py\n逆时针旋转 90° $\\begin{bmatrix} 0 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix}$\n图片generaltransform.py\n剪切 $\\begin{bmatrix} 1 \u0026amp; 1 \\ 0 \u0026amp; 1 \\end{bmatrix}$\n图片generaltransform.py\n列线性相关 $\\begin{bmatrix} 2 \u0026amp; -2 \\ 1 \u0026amp; -1 \\end{bmatrix}$ (意味着其中一个向量是另一个向量的倍数)\n04-矩阵乘法与线性变换复合 #\r复合变换的几何本质\n核心定义: 是多个线性变换的有序组合, 通过追踪基向量的最终位置记录变换过程\n计算示例: 先旋转 (矩阵R = $\\begin{bmatrix} 0 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix}$) 再剪切 (矩阵S = $\\begin{bmatrix} 1 \u0026amp; 1 \\ 0 \u0026amp; 1 \\end{bmatrix}$), 复合矩阵S·R = $\\begin{bmatrix} 1 \u0026amp; -1 \\ 1 \u0026amp; 0 \\end{bmatrix}$\n顺序规则 : 矩阵乘法从右向左读 (如 f(g(x))), 源于函数复合的顺序逻辑\n矩阵乘法的计算与规则\n设 $M_1$ = $\\begin{bmatrix} 1 \u0026amp; -2 \\ 1 \u0026amp; 0 \\end{bmatrix}$, $M_2$ = $\\begin{bmatrix} 0 \u0026amp; 2 \\ 1 \u0026amp; 0 \\end{bmatrix}$\n基向量$\\hat{i}\u0026rsquo;$的路径:$M_1$ 的 $\\hat{i}\u0026rsquo;$ 经 $M_2$变换:\n1 X $\\begin{bmatrix} 0 \\ 1 \\end{bmatrix}$ + 1 X $\\begin{bmatrix} 2 \\ 0 \\end{bmatrix}$ = $\\begin{bmatrix} 0 \u0026amp; 2 \\ 1 \u0026amp; 0 \\end{bmatrix}$ = $\\begin{bmatrix} 0 + 2 \\ 1 + 0 \\end{bmatrix}$ = $\\begin{bmatrix} 2 \\ 1 \\end{bmatrix}$\n基向量$\\hat{j}\u0026rsquo;$的路径:$M_1$ 的 $\\hat{j}\u0026rsquo;$ 经 $M_2$变换:\n(-2) X $\\begin{bmatrix} 0 \\ 1 \\end{bmatrix}$ + 0 X $\\begin{bmatrix} 2 \\ 0 \\end{bmatrix}$ = $\\begin{bmatrix} 0 \u0026amp; 0 \\ -2 \u0026amp; 0 \\end{bmatrix}$ = $\\begin{bmatrix} 0 + 0 \\ -2 + 0 \\end{bmatrix}$ = $\\begin{bmatrix} 0 \\ -2 \\end{bmatrix}$\n复合矩阵:$\\begin{bmatrix} 2 \u0026amp; 0 \\ 1 \u0026amp; -2 \\end{bmatrix}$\n图片compoundtransformation.py\n通用公式\n$M_2 = \\begin{bmatrix} a \u0026amp; b \\ c \u0026amp; d \\end{bmatrix}, M_1 = \\begin{bmatrix} e \u0026amp; f \\ g \u0026amp; h \\end{bmatrix}$\n$M_2M_1 = \\begin{bmatrix} ae + bg \u0026amp; af + bh \\ ce + dg \u0026amp; cf + dh \\end{bmatrix}$\n运算性质\n图片commutativelaw.py\n不满足交换律:$M_1M_2 ≠ M_2M_1$ 满足结合律:(AB)C = A(BC) 补充说明\n三维空间中的扩展\n基向量增加: 引用Z轴方向的基向量 $\\hat{k}\u0026rsquo;$, 坐标 $\\begin{bmatrix} 0 \\ 0 \\ 1 \\end{bmatrix}$\n变换规则一致\n线性变换由$\\hat{i}\u0026rsquo;, \\hat{j}\u0026rsquo;, \\hat{k}\u0026rsquo;$变换后的位置决定\n向量变换计算规则与二维相同\n$M_1 \\vec{v} = x \\begin{bmatrix} a \\ b \\ c \\end{bmatrix} + y \\begin{bmatrix} d \\ e \\ f \\end{bmatrix} + z\\begin{bmatrix} g \\ h \\ i \\end{bmatrix}$\n05-行列式 #\r行列式的几何本质 行列式描述线性变换对空间体积或面积的缩放比例\n图片determinant.py\n正负号代表空间是否反转\n右手定理\n图片\n我们通常使用右手定理, 即指向前方的无名指代表 $\\hat{i}\u0026rsquo;$, 指向侧边的中指代表 $\\hat{j}\u0026rsquo;$, 指向上方的拇指代表 $\\hat{k}\u0026rsquo;$, 如果用左手表示这个空间, 说明空间取向翻转, 行列式为负\n特殊情况:\n图片detezeroone.py\n行列式 = 0: 空间被压缩至低维\n图片detezeroone.py\n行列式 = 1: 保持体积不变\n公式 $$ \\det \\begin{bmatrix} a \u0026amp; b \\ c \u0026amp; d \\end{bmatrix} = ad - bc $$\n图片detcode.py\nad: 表示基向量缩放后形成的矩形面积\nbc: 表示平行四边形沿对角线方向拉伸或压缩了多少\n视频末尾\n$$ \\det(M_1M_2) = \\det(M_1) \\cdot \\det(M_2) $$\n假设对单位正方形进行变换, M1 为放大 2 倍, M2 为放大 4 倍,\n$\\det(M_1M_2)$ 可以理解为先放大 4 倍再放大 2 倍, 即 1 x (4 x 2),\n$\\det(M_1) \\cdot \\det(M_2)$ 可以理解为 1 x 2 x 4,\n两者相等\n06-逆矩阵, 列空间与零空间 #\r线性方程组\n线性方程组是指包含若干未知量和相关方程的集合, 每个方程中的未知量仅有常系数, 并且这些未知量之间只进行加法运算. 这类方程组可以统一表示为向量方程: 例子:\n$$ \\begin{cases} 2x + 5y + 3z = -3 \\ 4x + 0y + 8z = 0 \\ 1x + 3y + 0z = 2 \\end{cases} $$\n可写成矩阵形式:\n$$ \\begin{bmatrix} 2 \u0026amp; 5 \u0026amp; 3 \\ 4 \u0026amp; 0 \u0026amp; 8 \\ 1 \u0026amp; 3 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix}x \\ y \\ z\\end{bmatrix} = \\begin{bmatrix}-3 \\ 0 \\ 2\\end{bmatrix} $$\n其中, 左侧矩阵为 $A$, 未知向量为 $X$, 右侧为 $V$, 即 $AX = V$. 逆矩阵的概念\n图片inversematrix.py\n逆矩阵 $A^{-1}$ 可以理解为\u0026quot;还原\u0026quot;变换的工具. 如果 $AX = V$, 那么 $X = A^{-1}V$, 即通过逆矩阵可以解出原始的未知数. 只有当 $A$ 是方阵且 $\\det(A) \\neq 0$ 时, 逆矩阵才存在. 如果矩阵把空间\u0026quot;压缩\u0026quot;了(降维), 逆矩阵就不存在. 特殊情况: 如果降维后, 某个向量正好落在目标空间上, 这个向量可以被逆变换还原. 术语解释\n###秩 (Rank):### 空间变换后的维度. 变换后是一维, 秩为1; 二维, 秩为2; 以此类推. ###列空间 (Column Space):### 所有可能的输出向量集合, 即 $Av$ 构成的空间, 由矩阵 $A$ 的列向量张成. ###张成空间 (Span) 与列空间的区别:### span 指任意向量集合的线性组合的所有可能结果, column space 是矩阵与任意向量相乘后所有可能结果的集合. span 可应用于任意向量集合, column space 与线性方程组 $Ax = v$ 的解存在性直接相关. ###满秩:### 秩与列数相等. ###零向量:### 坐标为 (0, 0) 的向量. 满秩时, 零向量是原点; 非满秩时, 有多个向量变成零向量. ###零空间/核 (Null Space/Kernel):### 变换后落在原点的所有向量的集合. 6-补充说明 非方阵 #\r非方阵是指行数和列数不相等($m \\neq n$)的矩阵. 例如: $\\begin{bmatrix}2 \u0026amp; -1 \u0026amp; 2 \\ 0 \u0026amp; 1 \u0026amp; 1\\end{bmatrix}$: 2 行 3 列, 表示从三维空间映射到二维空间(如三维空间中的点被投影到一个平面上). $\\begin{bmatrix}3 \u0026amp; 1 \\ 1 \u0026amp; 5 \\ 4 \u0026amp; 9\\end{bmatrix}$: 3 行 2 列, 表示从二维空间映射到三维空间(如二维平面上的点被拉伸到三维空间). $[1, 2]$: 1 行 2 列, 表示从二维空间映射到一维空间(如二维空间中的点被压缩到一条线上). ","date":"24 May 2025","externalUrl":null,"permalink":"/notes/foundation/linearalgebra/essenceoflinearalgebra_part2/","section":"Notes","summary":"","title":"EssenceOfLinearAlgebra_Part2","type":"notes"},{"content":"","externalUrl":null,"permalink":"/zh-cn/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/zh-cn/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/zh-cn/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/zh-cn/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]